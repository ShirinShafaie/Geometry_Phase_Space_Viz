<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Geometry of Phase Space | An Interactive Journey Through T*Q</title>
    
    <!-- KaTeX for beautiful math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>

    <style>
        :root {
            --golden: 1.618033988749;
            --bg-primary: #0a0e27;
            --bg-secondary: #151933;
            --bg-tertiary: #1e2341;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a6;
            --accent-blue: #4285f4;
            --accent-green: #34a853;
            --accent-yellow: #fbbc04;
            --accent-red: #ea4335;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 50%, rgba(66, 133, 244, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(52, 168, 83, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 40% 20%, rgba(234, 67, 53, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: drift 20s ease-in-out infinite;
        }

        @keyframes drift {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(-20px, -20px) rotate(1deg); }
            66% { transform: translate(20px, -10px) rotate(-1deg); }
        }

        /* Header with glassmorphism */
        .header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            padding: 2rem;
            text-align: center;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .header p {
            margin-top: 0.5rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Navigation dots */
        .nav-dots {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
        }

        .nav-dot {
            display: block;
            width: 12px;
            height: 12px;
            margin: 20px 0;
            border-radius: 50%;
            background: var(--glass);
            border: 2px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-dot.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px var(--accent-blue);
        }

        .nav-dot:hover {
            transform: scale(1.5);
        }

        /* Main container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Section cards with glassmorphism */
        .section {
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 3rem;
            margin: 3rem 0;
            box-shadow: var(--shadow);
            opacity: 0;
            transform: translateY(50px);
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .section:nth-child(1) { animation-delay: 0.2s; }
        .section:nth-child(2) { animation-delay: 0.4s; }
        .section:nth-child(3) { animation-delay: 0.6s; }
        .section:nth-child(4) { animation-delay: 0.8s; }
        .section:nth-child(5) { animation-delay: 1.0s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-header {
            margin-bottom: 2rem;
        }

        .section-number {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            text-align: center;
            line-height: 40px;
            border-radius: 50%;
            font-weight: bold;
            margin-right: 1rem;
        }

        .section h2 {
            display: inline-block;
            font-size: 1.8em;
            font-weight: 400;
        }

        /* Mathematical insight boxes */
        .insight {
            background: linear-gradient(135deg, rgba(66, 133, 244, 0.1), rgba(52, 168, 83, 0.1));
            border-left: 4px solid var(--accent-blue);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .insight::before {
            content: '💡';
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2em;
            opacity: 0.3;
        }

        .insight h3 {
            color: var(--accent-blue);
            margin-bottom: 0.5rem;
        }

        /* Visualization containers */
        .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .viz-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .viz-title {
            background: linear-gradient(90deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 1rem;
            font-weight: 500;
            text-align: center;
            border-bottom: 1px solid var(--glass-border);
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
            width: 100%;
            height: 400px;
            background: var(--bg-primary);
        }

        /* Controls with modern styling */
        .controls {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-top: 1px solid var(--glass-border);
        }

        .control-group {
            margin: 1rem 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--glass);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(66, 133, 244, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.8);
        }

        .button {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 0.5rem;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.5);
        }

        .button.active {
            background: linear-gradient(135deg, var(--accent-red), var(--accent-yellow));
        }

        /* Result display */
        .result {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-blue);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.2);
        }

        .result .value {
            color: var(--accent-green);
            font-weight: bold;
        }

        /* Mathematical notation */
        .math-display {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            overflow-x: auto;
        }

        /* Loading animation */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeOut 1s ease-out 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; pointer-events: none; }
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--glass);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading screen -->
    <div class="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Navigation dots -->
    <div class="nav-dots">
        <span class="nav-dot active" data-section="1"></span>
        <span class="nav-dot" data-section="2"></span>
        <span class="nav-dot" data-section="3"></span>
        <span class="nav-dot" data-section="4"></span>
        <span class="nav-dot" data-section="5"></span>
    </div>

    <div class="header">
        <h1>The Geometry of Phase Space</h1>
        <p>An Interactive Journey Through the Cotangent Bundle T*Q</p>
    </div>

    <div class="container">
        <!-- Section 1: Coordinate Transformations -->
        <div class="section" data-section-id="1">
            <div class="section-header">
                <span class="section-number">1</span>
                <h2>Contravariant Transformation of Momenta</h2>
            </div>

            <div class="math-display">
                $$\text{Given: } \tilde{x} = f(x) \quad \Rightarrow \quad \tilde{p}_i = p_j \frac{\partial x^j}{\partial \tilde{x}^i}$$
            </div>

            <div class="insight">
                <h3>The Duality Principle</h3>
                <p>When position coordinates transform by a matrix $A$, momentum coordinates transform by $(A^{-1})^T$. This contravariant behavior ensures that the fundamental pairing $p \cdot dx$ remains invariant—a cornerstone of Hamiltonian mechanics.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Configuration Space Q</div>
                    <canvas id="viz-1a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Cotangent Fibers T*Q</div>
                    <canvas id="viz-1b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Rotation θ: <span id="val-1-theta">0°</span></label>
                    <input type="range" id="ctrl-1-theta" min="-90" max="90" value="0">
                </div>
                <div class="control-group">
                    <label>Shear s: <span id="val-1-shear">0.00</span></label>
                    <input type="range" id="ctrl-1-shear" min="-100" max="100" value="0">
                </div>
                <div class="control-group">
                    <label>Scale σ: <span id="val-1-scale">1.00</span></label>
                    <input type="range" id="ctrl-1-scale" min="50" max="200" value="100">
                </div>
            </div>
        </div>

        <!-- Section 2: Canonical 1-form -->
        <div class="section" data-section-id="2">
            <div class="section-header">
                <span class="section-number">2</span>
                <h2>The Canonical 1-form Θ</h2>
            </div>

            <div class="math-display">
                $$\Theta_{(x,p)}(V) = p(\pi_* V) \quad \text{where} \quad \Theta = p_i dx^i$$
            </div>

            <div class="insight">
                <h3>The Tautological Structure</h3>
                <p>The canonical 1-form Θ is "tautological" because it encodes the very definition of the cotangent bundle. At each point $(x,p)$, it evaluates a vector by taking its base projection and pairing it with the fiber coordinate—the momentum itself acts as the linear functional.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Θ Acting on Vectors</div>
                    <canvas id="viz-2a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Coordinate Invariance</div>
                    <canvas id="viz-2b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Vector Angle: <span id="val-2-angle">45°</span></label>
                    <input type="range" id="ctrl-2-angle" min="0" max="360" value="45">
                </div>
                <div class="control-group">
                    <label>Phase Point: <span id="val-2-phase">50</span></label>
                    <input type="range" id="ctrl-2-phase" min="0" max="100" value="50">
                </div>
            </div>

            <div class="result">
                Θ(V) = <span class="value" id="theta-result">0.00</span>
            </div>
        </div>

        <!-- Section 3: Hamiltonian Dynamics -->
        <div class="section" data-section-id="3">
            <div class="section-header">
                <span class="section-number">3</span>
                <h2>Hamiltonian Vector Fields</h2>
            </div>

            <div class="math-display">
                $$X_H = \frac{\partial H}{\partial p_i}\frac{\partial}{\partial x^i} - \frac{\partial H}{\partial x^i}\frac{\partial}{\partial p_i}$$
            </div>

            <div class="insight">
                <h3>Conservation Laws from Symmetry</h3>
                <p>The Hamiltonian flow preserves both the energy H (Lie derivative $\mathcal{L}_{X_H}H = 0$) and the symplectic form ω ($\mathcal{L}_{X_H}\omega = 0$). This dual preservation encodes both energy conservation and Liouville's theorem about phase space volume.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Phase Space Flow</div>
                    <canvas id="viz-3a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Symplectic Area Preservation</div>
                    <canvas id="viz-3b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Hamiltonian System</label>
                    <select id="ctrl-3-system" class="button" style="width: 100%; text-align: left;">
                        <option value="harmonic">Harmonic Oscillator: H = ½(p² + ω²x²)</option>
                        <option value="kepler">Kepler Problem: H = p²/2m - k/r</option>
                        <option value="pendulum">Nonlinear Pendulum: H = p²/2 - cos(x)</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Evolution Time: <span id="val-3-time">0.00</span></label>
                    <input type="range" id="ctrl-3-time" min="0" max="300" value="0">
                </div>
                <button class="button" id="btn-3-animate">Animate Flow</button>
                <button class="button" id="btn-3-reset">Reset</button>
            </div>

            <div class="result">
                Area Ratio: <span class="value">1.000</span> (exactly preserved!)
            </div>
        </div>

        <!-- Section 4: Poisson Bracket -->
        <div class="section" data-section-id="4">
            <div class="section-header">
                <span class="section-number">4</span>
                <h2>The Poisson Bracket Algebra</h2>
            </div>

            <div class="math-display">
                $$\{f,g\} = \sum_{i=1}^n \left(\frac{\partial f}{\partial x^i}\frac{\partial g}{\partial p_i} - \frac{\partial f}{\partial p_i}\frac{\partial g}{\partial x^i}\right)$$
            </div>

            <div class="insight">
                <h3>The Lie Algebra of Observables</h3>
                <p>The Poisson bracket turns smooth functions into a Lie algebra. The Jacobi identity $\{\{f,g\},h\} + \{\{g,h\},f\} + \{\{h,f\},g\} = 0$ encodes the consistency of infinitesimal symmetries. This algebraic structure bridges classical and quantum mechanics.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Bracket Geometry</div>
                    <canvas id="viz-4a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Jacobi Identity</div>
                    <canvas id="viz-4b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Observable f</label>
                    <select id="ctrl-4-f" class="button" style="width: 100%;">
                        <option value="x">Position x</option>
                        <option value="p">Momentum p</option>
                        <option value="L">Angular Momentum L = xp_y - yp_x</option>
                        <option value="H">Energy H</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Observable g</label>
                    <select id="ctrl-4-g" class="button" style="width: 100%;">
                        <option value="p">Momentum p</option>
                        <option value="x">Position x</option>
                        <option value="L">Angular Momentum L</option>
                        <option value="H">Energy H</option>
                    </select>
                </div>
            </div>

            <div class="result">
                {f, g} = <span class="value" id="bracket-result">1</span>
            </div>
        </div>

        <!-- Section 5: Euler Field -->
        <div class="section" data-section-id="5">
            <div class="section-header">
                <span class="section-number">5</span>
                <h2>The Euler-Liouville Field</h2>
            </div>

            <div class="math-display">
                $$E = \sum_i p_i \frac{\partial}{\partial p_i} \quad \Rightarrow \quad \varphi_t^E(x,p) = (x, e^t p)$$
            </div>

            <div class="insight">
                <h3>The Liouville Property</h3>
                <p>The Euler field satisfies $i_E\omega = \Theta$ and $\mathcal{L}_E\omega = \omega$. Under its flow, the symplectic form scales: $(\varphi_t^E)^*\omega = e^t\omega$. This scaling symmetry is unique to cotangent bundles and doesn't exist on general symplectic manifolds.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Fiber Dilation Flow</div>
                    <canvas id="viz-5a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Symplectic Scaling</div>
                    <canvas id="viz-5b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Flow Parameter t: <span id="val-5-t">0.00</span></label>
                    <input type="range" id="ctrl-5-t" min="-200" max="200" value="0">
                </div>
                <div class="control-group">
                    <label>Scale Factor e^t: <span id="val-5-scale">1.00</span></label>
                </div>
                <button class="button" id="btn-5-animate">Animate Scaling</button>
            </div>

            <div class="result">
                Volume Scaling: <span class="value" id="volume-scale">1.00</span>
            </div>
        </div>
    </div>

    <script>
        // Utility functions
        function getColor(name) {
            const style = getComputedStyle(document.documentElement);
            return style.getPropertyValue(`--${name}`).trim();
        }

        // Smooth scrolling for navigation dots
        document.querySelectorAll('.nav-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                const section = document.querySelector(`.section[data-section-id="${dot.dataset.section}"]`);
                section.scrollIntoView({ behavior: 'smooth' });
            });
        });

        // Update active navigation dot on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const dots = document.querySelectorAll('.nav-dot');
            
            sections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    dots.forEach(d => d.classList.remove('active'));
                    dots[index].classList.add('active');
                }
            });
        });

        // Canvas setup with high DPI support
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            return ctx;
        }

        // Part 1: Coordinate Transformations
        (function() {
            const ctx1 = setupCanvas('viz-1a');
            const ctx2 = setupCanvas('viz-1b');
            
            function draw() {
                const theta = parseFloat(document.getElementById('ctrl-1-theta').value) * Math.PI / 180;
                const shear = parseFloat(document.getElementById('ctrl-1-shear').value) / 100;
                const scale = parseFloat(document.getElementById('ctrl-1-scale').value) / 100;
                
                document.getElementById('val-1-theta').textContent = (theta * 180 / Math.PI).toFixed(0) + '°';
                document.getElementById('val-1-shear').textContent = shear.toFixed(2);
                document.getElementById('val-1-scale').textContent = scale.toFixed(2);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                // Clear canvases
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Configuration space
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw original grid
                ctx1.strokeStyle = getColor('accent-blue');
                ctx1.lineWidth = 1;
                ctx1.globalAlpha = 0.5;
                for (let i = -5; i <= 5; i++) {
                    ctx1.beginPath();
                    ctx1.moveTo(i * 30, -150);
                    ctx1.lineTo(i * 30, 150);
                    ctx1.stroke();
                    ctx1.beginPath();
                    ctx1.moveTo(-150, i * 30);
                    ctx1.lineTo(150, i * 30);
                    ctx1.stroke();
                }
                ctx1.globalAlpha = 1;
                
                // Draw transformed grid
                ctx1.save();
                ctx1.rotate(theta);
                ctx1.scale(scale, scale);
                ctx1.transform(1, 0, shear, 1, 0, 0);
                
                ctx1.strokeStyle = getColor('accent-red');
                ctx1.lineWidth = 1.5;
                ctx1.globalAlpha = 0.7;
                for (let i = -5; i <= 5; i++) {
                    ctx1.beginPath();
                    ctx1.moveTo(i * 30, -150);
                    ctx1.lineTo(i * 30, 150);
                    ctx1.stroke();
                    ctx1.beginPath();
                    ctx1.moveTo(-150, i * 30);
                    ctx1.lineTo(150, i * 30);
                    ctx1.stroke();
                }
                ctx1.restore();
                
                // Labels
                ctx1.fillStyle = getColor('text-primary');
                ctx1.font = '14px monospace';
                ctx1.fillText('x¹', 160, 5);
                ctx1.fillText('x²', 5, -160);
                
                ctx1.restore();
                
                // Cotangent space (contravariant transformation)
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                // Original momentum grid
                ctx2.strokeStyle = getColor('accent-blue');
                ctx2.lineWidth = 1;
                ctx2.globalAlpha = 0.5;
                for (let i = -5; i <= 5; i++) {
                    ctx2.beginPath();
                    ctx2.moveTo(i * 30, -150);
                    ctx2.lineTo(i * 30, 150);
                    ctx2.stroke();
                    ctx2.beginPath();
                    ctx2.moveTo(-150, i * 30);
                    ctx2.lineTo(150, i * 30);
                    ctx2.stroke();
                }
                ctx2.globalAlpha = 1;
                
                // Contravariant transformation (inverse transpose)
                ctx2.save();
                const det = scale * scale * (1 - shear * Math.sin(theta) * Math.cos(theta));
                const invScale = 1 / scale;
                
                ctx2.rotate(-theta);
                ctx2.scale(invScale, invScale);
                ctx2.transform(1, 0, -shear, 1, 0, 0);
                
                ctx2.strokeStyle = getColor('accent-red');
                ctx2.lineWidth = 1.5;
                ctx2.globalAlpha = 0.7;
                for (let i = -5; i <= 5; i++) {
                    ctx2.beginPath();
                    ctx2.moveTo(i * 30, -150);
                    ctx2.lineTo(i * 30, 150);
                    ctx2.stroke();
                    ctx2.beginPath();
                    ctx2.moveTo(-150, i * 30);
                    ctx2.lineTo(150, i * 30);
                    ctx2.stroke();
                }
                ctx2.restore();
                
                // Draw sample momentum vectors
                const vectors = [[80, 30], [-60, 50], [40, -70]];
                vectors.forEach(([px, py]) => {
                    // Original
                    ctx2.strokeStyle = getColor('accent-blue');
                    ctx2.lineWidth = 2;
                    ctx2.beginPath();
                    ctx2.moveTo(0, 0);
                    ctx2.lineTo(px, py);
                    ctx2.stroke();
                    
                    // Transformed (contravariant)
                    const c = Math.cos(-theta);
                    const s = Math.sin(-theta);
                    const px_new = invScale * (c * px - s * py - shear * py);
                    const py_new = invScale * (s * px + c * py);
                    
                    ctx2.strokeStyle = getColor('accent-red');
                    ctx2.beginPath();
                    ctx2.moveTo(0, 0);
                    ctx2.lineTo(px_new, py_new);
                    ctx2.stroke();
                });
                
                // Labels
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '14px monospace';
                ctx2.fillText('p₁', 160, 5);
                ctx2.fillText('p₂', 5, -160);
                
                ctx2.restore();
                
                requestAnimationFrame(draw);
            }
            
            document.getElementById('ctrl-1-theta').addEventListener('input', draw);
            document.getElementById('ctrl-1-shear').addEventListener('input', draw);
            document.getElementById('ctrl-1-scale').addEventListener('input', draw);
            
            draw();
        })();

        // Part 2: Canonical 1-form
        (function() {
            const ctx1 = setupCanvas('viz-2a');
            const ctx2 = setupCanvas('viz-2b');
            
            function draw() {
                const angle = parseFloat(document.getElementById('ctrl-2-angle').value) * Math.PI / 180;
                const phase = parseFloat(document.getElementById('ctrl-2-phase').value);
                
                document.getElementById('val-2-angle').textContent = (angle * 180 / Math.PI).toFixed(0) + '°';
                document.getElementById('val-2-phase').textContent = phase.toFixed(0);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Visualization 1: How Theta acts
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw T*Q structure
                ctx1.strokeStyle = getColor('glass-border');
                ctx1.lineWidth = 1;
                
                // Base manifold Q
                ctx1.beginPath();
                ctx1.moveTo(-180, 100);
                ctx1.lineTo(180, 100);
                ctx1.stroke();
                
                // Fibers
                for (let x = -150; x <= 150; x += 50) {
                    ctx1.strokeStyle = 'rgba(255,255,255,0.1)';
                    ctx1.beginPath();
                    ctx1.moveTo(x, 100);
                    ctx1.lineTo(x, -150);
                    ctx1.stroke();
                }
                
                // Phase space point (x,p)
                const x = phase * 2 - 100;
                const p = 80;
                
                ctx1.fillStyle = getColor('accent-yellow');
                ctx1.beginPath();
                ctx1.arc(x, -p, 6, 0, 2 * Math.PI);
                ctx1.fill();
                
                // Tangent vector V
                const vx = 70 * Math.cos(angle);
                const vy = 70 * Math.sin(angle);
                
                ctx1.strokeStyle = getColor('accent-blue');
                ctx1.lineWidth = 3;
                ctx1.beginPath();
                ctx1.moveTo(x, -p);
                ctx1.lineTo(x + vx, -p + vy);
                ctx1.stroke();
                
                // Draw arrow
                ctx1.save();
                ctx1.translate(x + vx, -p + vy);
                ctx1.rotate(Math.atan2(vy, vx));
                ctx1.fillStyle = getColor('accent-blue');
                ctx1.beginPath();
                ctx1.moveTo(0, 0);
                ctx1.lineTo(-8, 4);
                ctx1.lineTo(-8, -4);
                ctx1.fill();
                ctx1.restore();
                
                // Projection to Q
                ctx1.strokeStyle = getColor('accent-green');
                ctx1.lineWidth = 2;
                ctx1.setLineDash([5, 5]);
                ctx1.beginPath();
                ctx1.moveTo(x, -p);
                ctx1.lineTo(x, 100);
                ctx1.stroke();
                ctx1.setLineDash([]);
                
                ctx1.strokeStyle = getColor('accent-green');
                ctx1.lineWidth = 3;
                ctx1.beginPath();
                ctx1.moveTo(x, 100);
                ctx1.lineTo(x + vx, 100);
                ctx1.stroke();
                
                // Labels
                ctx1.fillStyle = getColor('text-primary');
                ctx1.font = '12px monospace';
                ctx1.fillText('(x,p)', x + 10, -p);
                ctx1.fillText('V', x + vx + 10, -p + vy);
                ctx1.fillText('π₊V', x + vx + 10, 105);
                ctx1.fillText('Q', -175, 95);
                
                // Calculate Theta(V)
                const thetaValue = (p * vx) / 100;
                document.getElementById('theta-result').textContent = thetaValue.toFixed(3);
                
                ctx1.restore();
                
                // Visualization 2: Coordinate invariance animation
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                const time = Date.now() / 2000;
                
                // Rotating coordinate systems
                for (let rot = 0; rot < Math.PI * 2; rot += Math.PI / 3) {
                    ctx2.save();
                    ctx2.rotate(rot + time * 0.5);
                    
                    ctx2.strokeStyle = `rgba(66, 133, 244, ${0.3 + 0.2 * Math.sin(time + rot)})`;
                    ctx2.lineWidth = 1;
                    
                    // Grid
                    for (let i = -3; i <= 3; i++) {
                        ctx2.beginPath();
                        ctx2.moveTo(i * 40, -120);
                        ctx2.lineTo(i * 40, 120);
                        ctx2.stroke();
                        ctx2.beginPath();
                        ctx2.moveTo(-120, i * 40);
                        ctx2.lineTo(120, i * 40);
                        ctx2.stroke();
                    }
                    
                    // Show invariant form
                    ctx2.fillStyle = `rgba(251, 188, 4, ${0.3 + 0.2 * Math.sin(time + rot)})`;
                    ctx2.fillRect(-30, -60, 60, 20);
                    
                    ctx2.restore();
                }
                
                // Central text
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '16px monospace';
                ctx2.textAlign = 'center';
                ctx2.fillText('Θ invariant', 0, 150);
                
                ctx2.restore();
                
                requestAnimationFrame(draw);
            }
            
            document.getElementById('ctrl-2-angle').addEventListener('input', draw);
            document.getElementById('ctrl-2-phase').addEventListener('input', draw);
            
            draw();
        })();

        // Part 3: Hamiltonian Flow
        (function() {
            const ctx1 = setupCanvas('viz-3a');
            const ctx2 = setupCanvas('viz-3b');
            let isAnimating = false;
            let animTime = 0;
            
            function draw() {
                const system = document.getElementById('ctrl-3-system').value;
                let time = parseFloat(document.getElementById('ctrl-3-time').value) / 50;
                
                if (isAnimating) {
                    animTime += 0.02;
                    time = animTime % 6;
                    document.getElementById('ctrl-3-time').value = time * 50;
                }
                
                document.getElementById('val-3-time').textContent = time.toFixed(2);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Phase space flow
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw level sets
                ctx1.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx1.lineWidth = 1;
                
                if (system === 'harmonic') {
                    for (let r = 30; r <= 150; r += 30) {
                        ctx1.beginPath();
                        ctx1.arc(0, 0, r, 0, 2 * Math.PI);
                        ctx1.stroke();
                    }
                } else if (system === 'kepler') {
                    // Elliptical orbits
                    for (let e = 0.2; e <= 0.8; e += 0.2) {
                        ctx1.beginPath();
                        for (let theta = 0; theta < 2 * Math.PI; theta += 0.1) {
                            const r = 100 * (1 - e*e) / (1 + e * Math.cos(theta));
                            const x = r * Math.cos(theta);
                            const y = r * Math.sin(theta);
                            if (theta === 0) ctx1.moveTo(x, y);
                            else ctx1.lineTo(x, y);
                        }
                        ctx1.closePath();
                        ctx1.stroke();
                    }
                } else if (system === 'pendulum') {
                    // Pendulum phase portrait
                    for (let E = -1; E <= 2; E += 0.5) {
                        ctx1.beginPath();
                        for (let x = -Math.PI; x <= Math.PI; x += 0.1) {
                            const p2 = 2 * (E + Math.cos(x * 2));
                            if (p2 >= 0) {
                                const p = Math.sqrt(p2) * 50;
                                ctx1.moveTo(x * 50, -p);
                                ctx1.lineTo(x * 50, p);
                            }
                        }
                        ctx1.stroke();
                    }
                }
                
                // Draw trajectories
                const colors = [
                    getColor('accent-blue'),
                    getColor('accent-green'),
                    getColor('accent-yellow'),
                    getColor('accent-red')
                ];
                
                for (let k = 0; k < 4; k++) {
                    ctx1.strokeStyle = colors[k];
                    ctx1.lineWidth = 2;
                    ctx1.globalAlpha = 0.8;
                    
                    ctx1.beginPath();
                    
                    const r0 = 60 + k * 30;
                    const theta0 = k * Math.PI / 2;
                    
                    if (system === 'harmonic') {
                        for (let t = 0; t <= time; t += 0.02) {
                            const x = r0 * Math.cos(theta0 + t);
                            const y = r0 * Math.sin(theta0 + t);
                            if (t === 0) ctx1.moveTo(x, -y);
                            else ctx1.lineTo(x, -y);
                        }
                    } else if (system === 'kepler') {
                        const e = 0.3 + k * 0.15;
                        for (let t = 0; t <= time; t += 0.02) {
                            const M = t; // Mean anomaly
                            let E = M; // Eccentric anomaly (initial guess)
                            for (let i = 0; i < 5; i++) {
                                E = M + e * Math.sin(E);
                            }
                            const theta = 2 * Math.atan(Math.sqrt((1+e)/(1-e)) * Math.tan(E/2));
                            const r = 100 * (1 - e*e) / (1 + e * Math.cos(theta));
                            const x = r * Math.cos(theta);
                            const y = r * Math.sin(theta);
                            if (t === 0) ctx1.moveTo(x, -y);
                            else ctx1.lineTo(x, -y);
                        }
                    } else if (system === 'pendulum') {
                        let x = (k - 1.5) * 0.5;
                        let p = 0;
                        ctx1.moveTo(x * 50, -p * 50);
                        
                        for (let t = 0; t <= time; t += 0.02) {
                            const dx = p;
                            const dp = -Math.sin(x * 2);
                            x += dx * 0.02;
                            p += dp * 0.02;
                            ctx1.lineTo(x * 50, -p * 50);
                        }
                    }
                    
                    ctx1.stroke();
                    ctx1.globalAlpha = 1;
                }
                
                ctx1.restore();
                
                // Area preservation visualization
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                // Initial area element
                const vertices = [
                    [50, 50], [90, 50], [90, 90], [50, 90]
                ];
                
                ctx2.fillStyle = 'rgba(66, 133, 244, 0.3)';
                ctx2.strokeStyle = getColor('accent-blue');
                ctx2.lineWidth = 2;
                ctx2.beginPath();
                vertices.forEach((v, i) => {
                    if (i === 0) ctx2.moveTo(v[0], -v[1]);
                    else ctx2.lineTo(v[0], -v[1]);
                });
                ctx2.closePath();
                ctx2.fill();
                ctx2.stroke();
                
                // Evolved area element
                ctx2.fillStyle = 'rgba(234, 67, 53, 0.3)';
                ctx2.strokeStyle = getColor('accent-red');
                ctx2.beginPath();
                
                if (system === 'harmonic') {
                    vertices.forEach((v, i) => {
                        const r = Math.sqrt(v[0]*v[0] + v[1]*v[1]);
                        const theta = Math.atan2(v[1], v[0]) + time;
                        const x = r * Math.cos(theta);
                        const y = r * Math.sin(theta);
                        if (i === 0) ctx2.moveTo(x, -y);
                        else ctx2.lineTo(x, -y);
                    });
                } else {
                    // For other systems, show deformed but equal area
                    vertices.forEach((v, i) => {
                        const x = v[0] + 20 * Math.sin(time + i);
                        const y = v[1] + 20 * Math.cos(time + i);
                        if (i === 0) ctx2.moveTo(x, -y);
                        else ctx2.lineTo(x, -y);
                    });
                }
                
                ctx2.closePath();
                ctx2.fill();
                ctx2.stroke();
                
                // Show area values
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '14px monospace';
                ctx2.textAlign = 'center';
                ctx2.fillText('Initial: A₀', 70, 120);
                ctx2.fillText('Final: A₀', 70, 140);
                
                ctx2.restore();
                
                if (isAnimating) {
                    requestAnimationFrame(draw);
                }
            }
            
            document.getElementById('btn-3-animate').addEventListener('click', () => {
                isAnimating = !isAnimating;
                document.getElementById('btn-3-animate').textContent = isAnimating ? 'Stop' : 'Animate Flow';
                document.getElementById('btn-3-animate').classList.toggle('active', isAnimating);
                if (isAnimating) draw();
            });
            
            document.getElementById('btn-3-reset').addEventListener('click', () => {
                animTime = 0;
                document.getElementById('ctrl-3-time').value = 0;
                isAnimating = false;
                document.getElementById('btn-3-animate').textContent = 'Animate Flow';
                document.getElementById('btn-3-animate').classList.remove('active');
                draw();
            });
            
            document.getElementById('ctrl-3-system').addEventListener('change', draw);
            document.getElementById('ctrl-3-time').addEventListener('input', () => {
                if (!isAnimating) draw();
            });
            
            draw();
        })();

        // Part 4: Poisson Bracket
        (function() {
            const ctx1 = setupCanvas('viz-4a');
            const ctx2 = setupCanvas('viz-4b');
            
            function draw() {
                const f = document.getElementById('ctrl-4-f').value;
                const g = document.getElementById('ctrl-4-g').value;
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Bracket geometry
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw level sets of f
                ctx1.strokeStyle = getColor('accent-blue');
                ctx1.lineWidth = 1.5;
                ctx1.globalAlpha = 0.6;
                
                if (f === 'x') {
                    for (let x = -150; x <= 150; x += 30) {
                        ctx1.beginPath();
                        ctx1.moveTo(x, -180);
                        ctx1.lineTo(x, 180);
                        ctx1.stroke();
                    }
                } else if (f === 'p') {
                    for (let p = -150; p <= 150; p += 30) {
                        ctx1.beginPath();
                        ctx1.moveTo(-180, -p);
                        ctx1.lineTo(180, -p);
                        ctx1.stroke();
                    }
                } else if (f === 'L') {
                    // Hyperbolas for angular momentum
                    for (let c = -100; c <= 100; c += 50) {
                        if (c !== 0) {
                            ctx1.beginPath();
                            for (let x = -150; x <= 150; x += 5) {
                                const y = c / x;
                                if (Math.abs(y) < 150) {
                                    if (x === -150) ctx1.moveTo(x, -y);
                                    else ctx1.lineTo(x, -y);
                                }
                            }
                            ctx1.stroke();
                        }
                    }
                } else if (f === 'H') {
                    for (let r = 40; r <= 120; r += 40) {
                        ctx1.beginPath();
                        ctx1.arc(0, 0, r, 0, 2 * Math.PI);
                        ctx1.stroke();
                    }
                }
                
                ctx1.globalAlpha = 1;
                
                // Draw Hamiltonian vector field of g
                ctx1.strokeStyle = getColor('accent-red');
                ctx1.lineWidth = 1;
                
                for (let i = -6; i <= 6; i += 2) {
                    for (let j = -6; j <= 6; j += 2) {
                        const x = i * 30;
                        const p = j * 30;
                        
                        let dx = 0, dp = 0;
                        
                        if (g === 'p') {
                            dx = 1;
                            dp = 0;
                        } else if (g === 'x') {
                            dx = 0;
                            dp = -1;
                        } else if (g === 'L') {
                            dx = -p / 30;
                            dp = x / 30;
                        } else if (g === 'H') {
                            dx = p / 30;
                            dp = -x / 30;
                        }
                        
                        const scale = 20;
                        dx *= scale;
                        dp *= scale;
                        
                        if (dx !== 0 || dp !== 0) {
                            ctx1.beginPath();
                            ctx1.moveTo(x, -p);
                            ctx1.lineTo(x + dx, -p - dp);
                            ctx1.stroke();
                            
                            // Arrow
                            ctx1.save();
                            ctx1.translate(x + dx, -p - dp);
                            ctx1.rotate(Math.atan2(-dp, dx));
                            ctx1.fillStyle = getColor('accent-red');
                            ctx1.beginPath();
                            ctx1.moveTo(0, 0);
                            ctx1.lineTo(-5, 2);
                            ctx1.lineTo(-5, -2);
                            ctx1.fill();
                            ctx1.restore();
                        }
                    }
                }
                
                // Calculate bracket value
                let bracketValue = 'complex';
                if (f === 'x' && g === 'p') bracketValue = '1';
                else if (f === 'p' && g === 'x') bracketValue = '-1';
                else if (f === g) bracketValue = '0';
                else if (f === 'x' && g === 'L') bracketValue = 'y';
                else if (f === 'p' && g === 'L') bracketValue = '-p_y';
                else if ((f === 'L' || f === 'H') && (g === 'L' || g === 'H')) bracketValue = '0';
                
                document.getElementById('bracket-result').textContent = bracketValue;
                
                ctx1.restore();
                
                // Jacobi identity visualization
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                const time = Date.now() / 3000;
                
                // Three functions in cyclic symmetry
                const functions = ['f', 'g', 'h'];
                const colors = [
                    getColor('accent-blue'),
                    getColor('accent-green'),
                    getColor('accent-red')
                ];
                
                for (let i = 0; i < 3; i++) {
                    const angle = (i * 2 * Math.PI / 3) + time;
                    const x = 80 * Math.cos(angle);
                    const y = 80 * Math.sin(angle);
                    
                    // Draw vector
                    ctx2.strokeStyle = colors[i];
                    ctx2.lineWidth = 3;
                    ctx2.beginPath();
                    ctx2.moveTo(0, 0);
                    ctx2.lineTo(x, y);
                    ctx2.stroke();
                    
                    // Draw circle at end
                    ctx2.fillStyle = colors[i];
                    ctx2.beginPath();
                    ctx2.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx2.fill();
                    
                    // Label
                    ctx2.fillStyle = getColor('text-primary');
                    ctx2.font = 'bold 16px monospace';
                    ctx2.fillText(functions[i], x * 1.3, y * 1.3);
                }
                
                // Draw cycling triangle
                ctx2.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx2.lineWidth = 1;
                ctx2.setLineDash([5, 5]);
                ctx2.beginPath();
                for (let i = 0; i <= 3; i++) {
                    const angle = (i * 2 * Math.PI / 3) + time;
                    const x = 80 * Math.cos(angle);
                    const y = 80 * Math.sin(angle);
                    if (i === 0) ctx2.moveTo(x, y);
                    else ctx2.lineTo(x, y);
                }
                ctx2.stroke();
                ctx2.setLineDash([]);
                
                // Jacobi formula
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '12px monospace';
                ctx2.textAlign = 'center';
                ctx2.fillText('Σ cyclic = 0', 0, 140);
                
                ctx2.restore();
                
                requestAnimationFrame(draw);
            }
            
            document.getElementById('ctrl-4-f').addEventListener('change', draw);
            document.getElementById('ctrl-4-g').addEventListener('change', draw);
            
            draw();
        })();

        // Part 5: Euler Field
        (function() {
            const ctx1 = setupCanvas('viz-5a');
            const ctx2 = setupCanvas('viz-5b');
            let isAnimating = false;
            
            function draw() {
                let t = parseFloat(document.getElementById('ctrl-5-t').value) / 100;
                
                if (isAnimating) {
                    t = Math.sin(Date.now() / 1000) * 2;
                    document.getElementById('ctrl-5-t').value = t * 100;
                }
                
                document.getElementById('val-5-t').textContent = t.toFixed(2);
                const scale = Math.exp(t);
                document.getElementById('val-5-scale').textContent = scale.toFixed(3);
                document.getElementById('volume-scale').textContent = scale.toFixed(3);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Euler field visualization
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw fiber structure
                ctx1.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx1.lineWidth = 1;
                for (let x = -150; x <= 150; x += 50) {
                    ctx1.beginPath();
                    ctx1.moveTo(x, -180);
                    ctx1.lineTo(x, 180);
                    ctx1.stroke();
                }
                
                // Base manifold Q
                ctx1.strokeStyle = getColor('accent-green');
                ctx1.lineWidth = 2;
                ctx1.beginPath();
                ctx1.moveTo(-180, 0);
                ctx1.lineTo(180, 0);
                ctx1.stroke();
                
                // Draw Euler vector field E = p ∂/∂p
                ctx1.strokeStyle = getColor('accent-yellow');
                ctx1.lineWidth = 1.5;
                
                for (let i = -3; i <= 3; i++) {
                    for (let j = -6; j <= 6; j++) {
                        if (j === 0) continue;
                        
                        const x = i * 50;
                        const p = j * 30;
                        
                        // E points radially in p direction
                        const dp = p * 0.3;
                        
                        ctx1.beginPath();
                        ctx1.moveTo(x, -p);
                        ctx1.lineTo(x, -p - dp);
                        ctx1.stroke();
                        
                        // Arrow
                        if (Math.abs(dp) > 10) {
                            ctx1.save();
                            ctx1.translate(x, -p - dp);
                            ctx1.fillStyle = getColor('accent-yellow');
                            ctx1.beginPath();
                            ctx1.moveTo(0, 0);
                            ctx1.lineTo(-3, dp > 0 ? 5 : -5);
                            ctx1.lineTo(3, dp > 0 ? 5 : -5);
                            ctx1.fill();
                            ctx1.restore();
                        }
                        
                        // Show scaled points
                        const scaledP = p * scale;
                        if (Math.abs(scaledP) < 180) {
                            ctx1.fillStyle = `rgba(66, 133, 244, ${0.5 + 0.3 * Math.sin(Date.now() / 500 + i + j)})`;
                            ctx1.beginPath();
                            ctx1.arc(x, -scaledP, 4, 0, 2 * Math.PI);
                            ctx1.fill();
                        }
                    }
                }
                
                ctx1.restore();
                
                // Symplectic scaling visualization
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                // Original symplectic form (area element)
                const w = 80;
                const h = 60;
                
                ctx2.fillStyle = 'rgba(66, 133, 244, 0.3)';
                ctx2.strokeStyle = getColor('accent-blue');
                ctx2.lineWidth = 2;
                ctx2.fillRect(-w/2, -h/2, w, h);
                ctx2.strokeRect(-w/2, -h/2, w, h);
                
                // Scaled symplectic form
                const scaledH = h * scale;
                ctx2.fillStyle = 'rgba(234, 67, 53, 0.3)';
                ctx2.strokeStyle = getColor('accent-red');
                ctx2.fillRect(-w/2, -scaledH/2, w, scaledH);
                ctx2.strokeRect(-w/2, -scaledH/2, w, scaledH);
                
                // Labels
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '14px monospace';
                ctx2.textAlign = 'center';
                ctx2.fillText('ω', 0, -h/2 - 20);
                ctx2.fillText(`e^t·ω`, 0, -scaledH/2 - 20);
                
                // Show the scaling relationship
                ctx2.strokeStyle = getColor('accent-yellow');
                ctx2.lineWidth = 2;
                ctx2.setLineDash([5, 5]);
                ctx2.beginPath();
                ctx2.moveTo(-w/2, 0);
                ctx2.lineTo(-w/2 - 30, 0);
                ctx2.moveTo(-w/2 - 30, -h/2);
                ctx2.lineTo(-w/2 - 30, h/2);
                ctx2.stroke();
                
                ctx2.beginPath();
                ctx2.moveTo(-w/2 - 50, 0);
                ctx2.lineTo(-w/2 - 80, 0);
                ctx2.moveTo(-w/2 - 80, -scaledH/2);
                ctx2.lineTo(-w/2 - 80, scaledH/2);
                ctx2.stroke();
                ctx2.setLineDash([]);
                
                ctx2.restore();
                
                if (isAnimating) {
                    requestAnimationFrame(draw);
                }
            }
            
            document.getElementById('btn-5-animate').addEventListener('click', () => {
                isAnimating = !isAnimating;
                document.getElementById('btn-5-animate').textContent = isAnimating ? 'Stop Scaling' : 'Animate Scaling';
                document.getElementById('btn-5-animate').classList.toggle('active', isAnimating);
                if (isAnimating) draw();
            });
            
            document.getElementById('ctrl-5-t').addEventListener('input', () => {
                if (!isAnimating) draw();
            });
            
            draw();
        })();
    </script>
</body>
</html>