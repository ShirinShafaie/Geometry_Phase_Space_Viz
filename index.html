<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Geometry of Phase Space | An Interactive Journey Through T*Q</title>
    
    <!-- KaTeX for beautiful math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>

    <style>
        :root {
            --golden: 1.618033988749;
            --bg-primary: #0a0e27;
            --bg-secondary: #151933;
            --bg-tertiary: #1e2341;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a6;
            --accent-blue: #4285f4;
            --accent-green: #34a853;
            --accent-yellow: #fbbc04;
            --accent-red: #ea4335;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 50%, rgba(66, 133, 244, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(52, 168, 83, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 40% 20%, rgba(234, 67, 53, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: drift 20s ease-in-out infinite;
        }

        @keyframes drift {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(-20px, -20px) rotate(1deg); }
            66% { transform: translate(20px, -10px) rotate(-1deg); }
        }

        /* Header with glassmorphism */
        .header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            padding: 2rem;
            text-align: center;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .header p {
            margin-top: 0.5rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Navigation dots */
        .nav-dots {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
        }

        .nav-dot {
            display: block;
            width: 12px;
            height: 12px;
            margin: 20px 0;
            border-radius: 50%;
            background: var(--glass);
            border: 2px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-dot.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px var(--accent-blue);
        }

        .nav-dot:hover {
            transform: scale(1.5);
        }

        /* Main container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Section cards with glassmorphism */
        .section {
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 3rem;
            margin: 3rem 0;
            box-shadow: var(--shadow);
            opacity: 0;
            transform: translateY(50px);
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .section:nth-child(1) { animation-delay: 0.2s; }
        .section:nth-child(2) { animation-delay: 0.4s; }
        .section:nth-child(3) { animation-delay: 0.6s; }
        .section:nth-child(4) { animation-delay: 0.8s; }
        .section:nth-child(5) { animation-delay: 1.0s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-header {
            margin-bottom: 2rem;
        }

        .section-number {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            text-align: center;
            line-height: 40px;
            border-radius: 50%;
            font-weight: bold;
            margin-right: 1rem;
        }

        .section h2 {
            display: inline-block;
            font-size: 1.8em;
            font-weight: 400;
        }

        /* Mathematical insight boxes */
        .insight {
            background: linear-gradient(135deg, rgba(66, 133, 244, 0.1), rgba(52, 168, 83, 0.1));
            border-left: 4px solid var(--accent-blue);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .insight::before {
            content: '💡';
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2em;
            opacity: 0.3;
        }

        .insight h3 {
            color: var(--accent-blue);
            margin-bottom: 0.5rem;
        }

        /* Visualization containers */
        .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .viz-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .viz-title {
            background: linear-gradient(90deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 1rem;
            font-weight: 500;
            text-align: center;
            border-bottom: 1px solid var(--glass-border);
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
            width: 100%;
            height: 400px;
            background: var(--bg-primary);
        }

        /* Controls with modern styling */
        .controls {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-top: 1px solid var(--glass-border);
        }

        .control-group {
            margin: 1rem 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--glass);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(66, 133, 244, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.8);
        }

        .button {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 0.5rem;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.5);
        }

        .button.active {
            background: linear-gradient(135deg, var(--accent-red), var(--accent-yellow));
        }

        /* Result display */
        .result {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-blue);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.2);
        }

        .result .value {
            color: var(--accent-green);
            font-weight: bold;
        }

        /* Mathematical notation */
        .math-display {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            overflow-x: auto;
        }

        /* Loading animation */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeOut 1s ease-out 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; pointer-events: none; }
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--glass);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <!-- Loading screen -->
    <div class="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Navigation dots -->
    <div class="nav-dots">
        <span class="nav-dot active" data-section="1"></span>
        <span class="nav-dot" data-section="2"></span>
        <span class="nav-dot" data-section="3"></span>
        <span class="nav-dot" data-section="4"></span>
        <span class="nav-dot" data-section="5"></span>
    </div>

    <div class="header">
        <h1>The Geometry of Phase Space</h1>
        <p>An Interactive Journey Through the Cotangent Bundle T*Q</p>
    </div>

    <div class="container"><!-- Context box -->
<div class="insight" id="context">
  <h3>Context</h3>
  <p>
    We have an $n$-dimensional manifold $Q$ with coordinates $(x^1,\dots,x^n)$.
    The cotangent bundle $T^*Q$ is a $2n$-dimensional manifold with coordinates
    $(x^1,\dots,x^n,\, p_1,\dots,p_n)$, where $p$ are the canonically conjugate
    momenta. In these coordinates, the bundle projection
    $\pi: T^*Q \to Q$ has the expression $\pi(x,p)=x$.
  </p>
</div>

        <!-- Section 1: Coordinate Transformations -->
        <div class="section" data-section-id="1">
            <div class="section-header">
                <span class="section-number">1</span>
                <h2>Coordinate Transformation of Conjugate Momenta</h2>
            </div>

            <div class="math-display">
  $$\textbf{Given: }\ \tilde{x}=f(x)\ \text{ with Jacobian }\ 
    J^i{}_{j}=\frac{\partial \tilde{x}^i}{\partial x^j}$$
  $$\textbf{Covector transformation (contragredient) law: }\ 
    \tilde{p}_i = p_j\,(J^{-1})^j{}_{i}
    = p_j\,\frac{\partial x^j}{\partial \tilde{x}^i}$$
</div>
            <div class="insight">
                <h3>The Duality Principle</h3>
                <p>When position coordinates transform by a matrix $A$, momentum coordinates transform by $(A^{-1})^T$. This inverse–transpose behaviour ensures that the fundamental pairing $p \cdot dx$ remains invariant: a cornerstone of Hamiltonian mechanics.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Configuration Space Q</div>
                    <canvas id="viz-1a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Cotangent Fibers T*Q</div>
                    <canvas id="viz-1b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Rotation θ: <span id="val-1-theta">0°</span></label>
                    <input type="range" id="ctrl-1-theta" min="-90" max="90" value="0">
                </div>
                <div class="control-group">
                    <label>x-shear k: <span id="val-1-shear">0.00</span></label>
                    <input type="range" id="ctrl-1-shear" min="-100" max="100" value="0">
                </div>
                <div class="control-group">
                    <label>Scale σ: <span id="val-1-scale">1.00</span></label>
                    <input type="range" id="ctrl-1-scale" min="50" max="200" value="100">
                </div>
            </div>
<div class="insight" id="notes-1">
  <h3>Quick Guide</h3>
  <ul style="margin-top:0.25rem">
    <li><strong>What changes:</strong> coordinates transform by the Jacobian 
      $J^i{}_j=\dfrac{\partial \tilde{x}^i}{\partial x^j}$ (rotate / scale / shear)
    </li>
    <li><strong>What co-changes:</strong> covectors (momenta) transform by the inverse transpose:
      $\ \tilde p_i = p_j\,(J^{-1})^j{}_i$
    </li>
    <li><strong>Why:</strong> to keep the canonical pairing $p_i\,dx^i$ invariant:
      $$p_i\,dx^i=\tilde p_i\,d\tilde x^i \quad\Longleftrightarrow\quad \tilde p_i = p_j\,(J^{-1})^j{}_i$$
    </li>
  </ul>
</div>
        </div>

        <!-- Section 2: Canonical 1-form -->
        <div class="section" data-section-id="2">
            <div class="section-header">
                <span class="section-number">2</span>
                <h2>The Canonical 1-form Θ</h2>
            </div>

            <div class="math-display">
                $$\Theta_{(x,p)}(V) = p(\pi_* V) \quad \text{where} \quad \Theta = p_i dx^i$$
            </div>

            <div class="insight">
                <h3>The Tautological Structure</h3>
                <p>The canonical 1-form Θ is "tautological" because it encodes the very definition of the cotangent bundle. At each point $(x,p)$, it evaluates a vector by taking its base projection and pairing it with the fiber coordinate—the momentum itself acts as the linear functional.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Θ Acting on Vectors</div>
                    <canvas id="viz-2a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Coordinate Invariance</div>
                    <canvas id="viz-2b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Vector Angle: <span id="val-2-angle">45°</span></label>
                    <input type="range" id="ctrl-2-angle" min="0" max="360" value="45">
                </div>
                <div class="control-group">
                    <label>Phase Point: <span id="val-2-phase">50</span></label>
                    <input type="range" id="ctrl-2-phase" min="0" max="100" value="50">
                </div>
            </div>

            <div class="result">
                Θ(V) = <span class="value" id="theta-result">0.00</span>
            </div>
<div class="insight" id="sec2-quick-guide">
  <h3>Quick Guide — Coordinate Invariance of Θ</h3>
  <ul>
    <li><strong>Definition:</strong> 
      $\,\Theta_{(x,p)}(V)=p(\pi_*V)=p_i\,dx^i(V)\,$
    </li>
    <li><strong>Change of coordinates:</strong> 
      $\,\tilde x^i=f^i(x)$ with Jacobian 
      $\,J^i{}_j=\dfrac{\partial\tilde x^i}{\partial x^j}\,$
    </li>
    <li><strong>Transformation laws:</strong> 
      $\,d\tilde x^i=J^i{}_j\,dx^j,\qquad 
      \tilde p_i=p_j\,(J^{-1})^j{}_i\,$
    </li>
    <li><strong>Invariance:</strong> 
      $\,\tilde p_i\,d\tilde x^i
      =p_j\,(J^{-1})^j{}_i\,J^i{}_k\,dx^k
      =p_k\,dx^k\,$
    </li>
    <li><strong>1D check (this panel):</strong> 
      $\,J=\dfrac{d\tilde x}{dx},\ \tilde p=\dfrac{p}{J},\ 
      d\tilde x(V)=J\,dx(V)\ \Rightarrow\ 
      \Theta(V)=\tilde\Theta(V)\,$
    </li>
  </ul>
</div>
<div class="insight" id="notes-2">
  <h3>Direct Algebraic Verification</h3>
  <p>From Section 1, we have the transformation laws:</p>
  <div class="math-display">
    $$\tilde{p}_i = p_j \frac{\partial x^j}{\partial \tilde{x}^i}, \quad d\tilde{x}^i = \frac{\partial \tilde{x}^i}{\partial x^k} dx^k$$
  </div>
  <p>Substituting into the transformed 1-form:</p>
  <div class="math-display">
    $$\begin{aligned}
    \tilde{p}_i d\tilde{x}^i &= \left(p_j \frac{\partial x^j}{\partial \tilde{x}^i}\right) \left(\frac{\partial \tilde{x}^i}{\partial x^k} dx^k\right) \\
    &= p_j \left(\frac{\partial x^j}{\partial \tilde{x}^i} \frac{\partial \tilde{x}^i}{\partial x^k}\right) dx^k \\
    &= p_j \delta^j_k dx^k \quad \text{(chain rule)} \\
    &= p_j dx^j \\
    &= p_i dx^i
    \end{aligned}$$
  </div>
  <p>This proves the coordinate invariance of the canonical 1-form Θ.</p>
</div>
        </div>

        <!-- Section 3: Hamiltonian Vector Fields - COMPLETELY REDONE -->
<div class="section" data-section-id="3">
    <div class="section-header">
        <span class="section-number">3</span>
        <h2>Hamiltonian Vector Fields and Symmetries</h2>
    </div>

    <div class="math-display">
  $$\omega = dp_i\wedge dx^i,\qquad V \mapsto i_V(\omega)=(dp_i(V))\,dx^i-(dx^i(V))\,dp_i$$
  $$H \mapsto X_H = -\,\omega^{-1} dH
    = \big(-\partial_{x^i}H\big)\,\partial_{p_i}
      + \big(\partial_{p_i}H\big)\,\partial_{x^i}$$
</div>

    <div class="insight">
        <h3>Infinitesimal Symmetries</h3>
        <p>Verify that $X_H$ is an infinitesimal symmetry of both $\omega$ and $H$:</p>
        <ul style="list-style-type: none; padding-left: 0;">
            <li><strong>1.</strong> $\mathcal{L}_{X_H}\omega = 0$ — The symplectic form is preserved</li>
            <li><strong>2.</strong> $\mathcal{L}_{X_H}H = 0$ — Energy is conserved along the flow</li>
        </ul>
        <p>These two properties encode the fundamental conservation laws of Hamiltonian mechanics.</p>
    </div>

    <div class="viz-container">
        <div class="viz-panel">
            <div class="viz-title">Hamiltonian Flow & Vector Field X_H</div>
            <canvas id="viz-3a"></canvas>
        </div>
        <div class="viz-panel">
            <div class="viz-title">Conservation Verification</div>
            <canvas id="viz-3b"></canvas>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Hamiltonian System</label>
            <select id="ctrl-3-system" class="button" style="width: 100%; text-align: left;">
                <option value="harmonic">Harmonic Oscillator: H = ½(p² + x²)</option>
                <option value="anharmonic">Anharmonic: H = ½p² + ¼x⁴</option>
                <option value="pendulum">Pendulum: H = ½p² - cos(x)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Evolution Time: <span id="val-3-time">0.00</span></label>
            <input type="range" id="ctrl-3-time" min="0" max="300" value="0">
        </div>
        <button class="button" id="btn-3-animate">Animate Flow</button>
        <button class="button" id="btn-3-reset">Reset</button>
    </div>

     <div class="result">
        <div>Max |ΔH|: <span class="value" id="delta-h">0.000000</span></div>
        <div>Max |div(X_H)|: <span class="value" id="div-xh">0.000000</span></div>
        <div>Area ratio A(t)/A₀: <span class="value" id="area-ratio">1.000000</span></div>
      </div>

<div class="insight" id="sec3-insight">
  <h3>Quick Guide — Why $\mathcal{L}_{X_H}\omega = 0$ and $\mathcal{L}_{X_H}H = 0$</h3>

  <p style="margin-top:.5rem">
    <strong>Cartan’s formula:</strong> $\ \mathcal{L}_{X_H}\omega = d\!\left(i_{X_H}\omega\right)+i_{X_H}(d\omega)$.
    Since $i_{X_H}\omega=-\,dH$ and $d\omega=0$, we get $\ \mathcal{L}_{X_H}\omega=d(-dH)+0=0$.
  </p>

  <div class="math-display" style="margin-top:1rem">
    $$\omega = dp_i \wedge dx^i,\qquad V \longmapsto i_V(\omega)=(dp_i(V))\,dx^i-(dx^i(V))\,dp_i$$
    $$H \mapsto X_H = -\,\omega^{-1} dH
      = \big(-\partial_{x^i}H\big)\,\partial_{p_i}
        + \big(\partial_{p_i}H\big)\,\partial_{x^i}$$
  </div>

  <div class="math-display" style="margin-top:1rem">
    $$\mathcal{L}_{X_H}H = X_H(H) = \frac{\partial H}{\partial p_i}\frac{\partial H}{\partial x^i}
      - \frac{\partial H}{\partial x^i}\frac{\partial H}{\partial p_i} = 0$$
  </div>

  <p style="margin-top:1rem">
    <strong>How to read the plots:</strong> the left panel draws $X_H$ and sample trajectories (level sets of $H$);
    the right panel evolves a region to show area preservation (Liouville).
  </p>
</div>

        <!-- Section 4: Poisson Bracket -->
        <div class="section" data-section-id="4">
            <div class="section-header">
                <span class="section-number">4</span>
                <h2>The Poisson Bracket Algebra</h2>
            </div>

            <div class="math-display">
                $$\{f,g\} = \sum_{i=1}^n \left(\frac{\partial f}{\partial x^i}\frac{\partial g}{\partial p_i} - \frac{\partial f}{\partial p_i}\frac{\partial g}{\partial x^i}\right)$$
            </div>

            <div class="insight">
                <h3>The Lie Algebra of Observables</h3>
                <p>The Poisson bracket turns smooth functions into a Lie algebra. The Jacobi identity $\{\{f,g\},h\} + \{\{g,h\},f\} + \{\{h,f\},g\} = 0$ encodes the consistency of infinitesimal symmetries. This algebraic structure bridges classical and quantum mechanics.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Bracket Geometry</div>
                    <canvas id="viz-4a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Jacobi Identity</div>
                    <canvas id="viz-4b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Observable f</label>
                    <select id="ctrl-4-f" class="button" style="width: 100%;">
                        <option value="x">Position x</option>
                        <option value="p">Momentum p</option>
                        <option value="L">Angular Momentum L = xp_y - yp_x</option>
                        <option value="H">Energy H</option>
                    </select>
                </div>
                <div class="control-group">
                    <label>Observable g</label>
                    <select id="ctrl-4-g" class="button" style="width: 100%;">
                        <option value="p">Momentum p</option>
                        <option value="x">Position x</option>
                        <option value="L">Angular Momentum L</option>
                        <option value="H">Energy H</option>
                    </select>
                </div>
            </div>

            <div class="result">
                {f, g} = <span class="value" id="bracket-result">1</span>
            </div>
        </div>

        <!-- Section 5: Euler Field -->
        <div class="section" data-section-id="5">
            <div class="section-header">
                <span class="section-number">5</span>
                <h2>The Euler-Liouville Field</h2>
            </div>

            <div class="math-display">
                $$E = \sum_i p_i \frac{\partial}{\partial p_i} \quad \Rightarrow \quad \varphi_t^E(x,p) = (x, e^t p)$$
            </div>

            <div class="insight">
                <h3>The Liouville Property</h3>
                <p>The Euler field satisfies $i_E\omega = \Theta$ and $\mathcal{L}_E\omega = \omega$. Under its flow, the symplectic form scales: $(\varphi_t^E)^*\omega = e^t\omega$. 
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Fiber Dilation Flow</div>
                    <canvas id="viz-5a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Symplectic Scaling</div>
                    <canvas id="viz-5b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Flow Parameter t: <span id="val-5-t">0.00</span></label>
                    <input type="range" id="ctrl-5-t" min="-200" max="200" value="0">
                </div>
                <div class="control-group">
                    <label>Scale Factor e^t: <span id="val-5-scale">1.00</span></label>
                </div>
                <button class="button" id="btn-5-animate">Animate Scaling</button>
            </div>

            <div class="result">
                Volume Scaling: <span class="value" id="volume-scale">1.00</span>
            </div>
        </div>
    </div>

    <script>
        // Utility functions
        function getColor(name) {
            const style = getComputedStyle(document.documentElement);
            return style.getPropertyValue(`--${name}`).trim();
        }

        // Smooth scrolling for navigation dots
        document.querySelectorAll('.nav-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                const section = document.querySelector(`.section[data-section-id="${dot.dataset.section}"]`);
                section.scrollIntoView({ behavior: 'smooth' });
            });
        });

        // Update active navigation dot on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const dots = document.querySelectorAll('.nav-dot');
            
            sections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    dots.forEach(d => d.classList.remove('active'));
                    dots[index].classList.add('active');
                }
            });
        });

        // Canvas setup with high DPI support
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            return ctx;
        }

        // Part 1: Coordinate Transformations
        (function() {
            const ctx1 = setupCanvas('viz-1a');
            const ctx2 = setupCanvas('viz-1b');
            
            function draw() {
                const theta = parseFloat(document.getElementById('ctrl-1-theta').value) * Math.PI / 180;
                const shear = parseFloat(document.getElementById('ctrl-1-shear').value) / 100;
                const scale = parseFloat(document.getElementById('ctrl-1-scale').value) / 100;
                
                document.getElementById('val-1-theta').textContent = (theta * 180 / Math.PI).toFixed(0) + '°';
                document.getElementById('val-1-shear').textContent = shear.toFixed(2);
                document.getElementById('val-1-scale').textContent = scale.toFixed(2);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                // Clear canvases
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Configuration space
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw original grid
                ctx1.strokeStyle = getColor('accent-blue');
                ctx1.lineWidth = 1;
                ctx1.globalAlpha = 0.5;
                for (let i = -5; i <= 5; i++) {
                    ctx1.beginPath();
                    ctx1.moveTo(i * 30, -150);
                    ctx1.lineTo(i * 30, 150);
                    ctx1.stroke();
                    ctx1.beginPath();
                    ctx1.moveTo(-150, i * 30);
                    ctx1.lineTo(150, i * 30);
                    ctx1.stroke();
                }
                ctx1.globalAlpha = 1;
                
                // Draw transformed grid
                ctx1.save();
                ctx1.rotate(theta);
                ctx1.scale(scale, scale);
                ctx1.transform(1, 0, shear, 1, 0, 0);
                
                ctx1.strokeStyle = getColor('accent-red');
                ctx1.lineWidth = 1.5;
                ctx1.globalAlpha = 0.7;
                for (let i = -5; i <= 5; i++) {
                    ctx1.beginPath();
                    ctx1.moveTo(i * 30, -150);
                    ctx1.lineTo(i * 30, 150);
                    ctx1.stroke();
                    ctx1.beginPath();
                    ctx1.moveTo(-150, i * 30);
                    ctx1.lineTo(150, i * 30);
                    ctx1.stroke();
                }
                ctx1.restore();
                
                // Labels
                ctx1.fillStyle = getColor('text-primary');
                ctx1.font = '14px monospace';
                ctx1.fillText('x¹', 160, 5);
                ctx1.fillText('x²', 5, -160);
                
                ctx1.restore();
                
                // Cotangent space (inverse–transpose)
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                // Original momentum grid
                ctx2.strokeStyle = getColor('accent-blue');
                ctx2.lineWidth = 1;
                ctx2.globalAlpha = 0.5;
                for (let i = -5; i <= 5; i++) {
                    ctx2.beginPath();
                    ctx2.moveTo(i * 30, -150);
                    ctx2.lineTo(i * 30, 150);
                    ctx2.stroke();
                    ctx2.beginPath();
                    ctx2.moveTo(-150, i * 30);
                    ctx2.lineTo(150, i * 30);
                    ctx2.stroke();
                }
                ctx2.globalAlpha = 1;
                
                // Contragredient transformation (inverse transpose)
                ctx2.save();
        	const invScale = 1 / scale;  
                
                ctx2.rotate(theta);
                ctx2.scale(invScale, invScale);
                ctx2.transform(1, -shear, 0, 1, 0, 0);
                
                ctx2.strokeStyle = getColor('accent-red');
                ctx2.lineWidth = 1.5;
                ctx2.globalAlpha = 0.7;
                for (let i = -5; i <= 5; i++) {
                    ctx2.beginPath();
                    ctx2.moveTo(i * 30, -150);
                    ctx2.lineTo(i * 30, 150);
                    ctx2.stroke();
                    ctx2.beginPath();
                    ctx2.moveTo(-150, i * 30);
                    ctx2.lineTo(150, i * 30);
                    ctx2.stroke();
                }
                ctx2.restore();
                
                // Draw sample momentum vectors
                const vectors = [[80, 30], [-60, 50], [40, -70]];
                vectors.forEach(([px, py]) => {
                    // Original
                    ctx2.strokeStyle = getColor('accent-blue');
                    ctx2.lineWidth = 2;
                    ctx2.beginPath();
                    ctx2.moveTo(0, 0);
                    ctx2.lineTo(px, -py);
                    ctx2.stroke();
                    
                    // Transformed by (J^{-1})^T = R(+θ) · S(1/σ) · [[1,0],[-k,1]]
// 1) y-shear with −k
let qx = px;
let qy = -shear * px + py;

// 2) scale by 1/σ
qx *= invScale;
qy *= invScale;

// 3) rotate by +θ
const c = Math.cos(theta), s = Math.sin(theta);
const px_new = c * qx - s * qy;
const py_new = s * qx + c * qy;

ctx2.strokeStyle = getColor('accent-red');
ctx2.beginPath();
ctx2.moveTo(0, 0);
ctx2.lineTo(px_new, -py_new);
ctx2.stroke();
                });
                
                // Labels
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '14px monospace';
                ctx2.fillText('p₁', 160, 5);
                ctx2.fillText('p₂', 5, -160);
                
                ctx2.restore();
                
                requestAnimationFrame(draw);
            }
            
            document.getElementById('ctrl-1-theta').addEventListener('input', draw);
            document.getElementById('ctrl-1-shear').addEventListener('input', draw);
            document.getElementById('ctrl-1-scale').addEventListener('input', draw);
            
            draw();
        })();

        // Part 2: Canonical 1-form  — upgraded right panel (numeric invariance check)
(function () {
  const ctx1 = setupCanvas('viz-2a');
  const ctx2 = setupCanvas('viz-2b');

  // small linear-algebra helpers (2×2)
  function mat(a,b,c,d){ return [[a,b],[c,d]]; }
  function mul(A,v){ return [A[0][0]*v[0] + A[0][1]*v[1], A[1][0]*v[0] + A[1][1]*v[1]]; }
  function invT(A){
    const [a,b] = A[0], [c,d] = A[1];
    const det = a*d - b*c;
    // (A^{-1})^T = 1/det * [[d, -c], [-b, a]]
    return [[ d/det, -c/det],
            [-b/det,  a/det]];
  }
  function rotScale(alpha, sigma){
    const c = Math.cos(alpha), s = Math.sin(alpha);
    // J = sigma * R(alpha)
    return mat(sigma*c, -sigma*s, sigma*s, sigma*c);
  }
  function draw() {
    // read your existing sliders (unchanged UI)
    const angle = parseFloat(document.getElementById('ctrl-2-angle').value) * Math.PI / 180;
    const phase = parseFloat(document.getElementById('ctrl-2-phase').value);

    document.getElementById('val-2-angle').textContent = (angle * 180 / Math.PI).toFixed(0) + '°';
    document.getElementById('val-2-phase').textContent = phase.toFixed(0);

    const w1 = ctx1.canvas.width / (window.devicePixelRatio || 1);
    const h1 = ctx1.canvas.height / (window.devicePixelRatio || 1);
    const w2 = ctx2.canvas.width / (window.devicePixelRatio || 1);
    const h2 = ctx2.canvas.height / (window.devicePixelRatio || 1);

    ctx1.clearRect(0, 0, w1, h1);
    ctx2.clearRect(0, 0, w2, h2);

    // ---------- LEFT PANEL (unchanged): Θ acting on vectors ----------
    ctx1.save();
    ctx1.translate(w1/2, h1/2);

    // base line Q
    ctx1.strokeStyle = getColor('glass-border');
    ctx1.lineWidth = 1;
    ctx1.beginPath();
    ctx1.moveTo(-180, 100);
    ctx1.lineTo(180, 100);
    ctx1.stroke();

    // fibers
    for (let x = -150; x <= 150; x += 50) {
      ctx1.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx1.beginPath(); ctx1.moveTo(x, 100); ctx1.lineTo(x, -150); ctx1.stroke();
    }

    const x = phase * 2 - 100;   // [-100,100]
    const p = 80;                 // momentum magnitude (your existing scale)
    ctx1.fillStyle = getColor('accent-yellow');
    ctx1.beginPath(); ctx1.arc(x, -p, 6, 0, 2*Math.PI); ctx1.fill();

    const vx = 70 * Math.cos(angle);
    const vy = 70 * Math.sin(angle);

    // tangent vector V
    ctx1.strokeStyle = getColor('accent-blue');
    ctx1.lineWidth = 3;
    ctx1.beginPath(); ctx1.moveTo(x, -p); ctx1.lineTo(x + vx, -p + vy); ctx1.stroke();
    ctx1.save();
    ctx1.translate(x + vx, -p + vy);
    ctx1.rotate(Math.atan2(vy, vx));
    ctx1.fillStyle = getColor('accent-blue');
    ctx1.beginPath(); ctx1.moveTo(0, 0); ctx1.lineTo(-8, 4); ctx1.lineTo(-8, -4); ctx1.fill();
    ctx1.restore();

    // projection π_*V to Q
    ctx1.strokeStyle = getColor('accent-green');
    ctx1.lineWidth = 2;
    ctx1.setLineDash([5,5]);
    ctx1.beginPath(); ctx1.moveTo(x, -p); ctx1.lineTo(x, 100); ctx1.stroke();
    ctx1.setLineDash([]);
    ctx1.beginPath(); ctx1.moveTo(x, 100); ctx1.lineTo(x + vx, 100); ctx1.stroke();

    // labels
    ctx1.fillStyle = getColor('text-primary');
    ctx1.font = '12px monospace';
    ctx1.fillText('(x,p)', x + 10, -p);
    ctx1.fillText('V',     x + vx + 10, -p + vy);
    ctx1.fillText('π_*V',  x + vx + 10, 105);
    ctx1.fillText('Q', -175, 95);

    // your original Θ(V) readout (kept consistent with your scaling)
    const thetaLeft = (p * vx) / 100;
    document.getElementById('theta-result').textContent = thetaLeft.toFixed(3);

    ctx1.restore();

    // ---------- RIGHT PANEL: numeric verification p·dx = p~·dx~ ----------
    ctx2.save();
    ctx2.translate(w2/2, h2/2);

    // animated coordinate change  x̃ = J x  with  J = σ R(α)
    const t = Date.now() / 1200;
    const alpha = 0.9 * Math.sin(t);                 // rotation
    const sigma = 1.2 + 0.3 * Math.sin(0.7 * t);     // isotropic scale
    const J = rotScale(alpha, sigma);
    const JinvT = invT(J);

    // draw original axes (blue)
    ctx2.strokeStyle = getColor('accent-blue');
    ctx2.lineWidth = 2; ctx2.globalAlpha = 0.9;
    ctx2.beginPath(); ctx2.moveTo(-150, 0); ctx2.lineTo(150, 0); ctx2.stroke();
    ctx2.beginPath(); ctx2.moveTo(0, -150); ctx2.lineTo(0, 150); ctx2.stroke();
    ctx2.globalAlpha = 1;
    ctx2.fillStyle = getColor('accent-blue');
    ctx2.font = '12px monospace';
    ctx2.fillText('x¹', 155, 5); ctx2.fillText('x²', 5, -155);

    // draw transformed axes (red)
    const e1 = [1,0], e2 = [0,1];
    const Je1 = mul(J, e1), Je2 = mul(J, e2);
    ctx2.strokeStyle = getColor('accent-red'); ctx2.lineWidth = 2; ctx2.globalAlpha = 0.8;
    ctx2.beginPath(); ctx2.moveTo(-150*Je1[0], 150*Je1[1]); ctx2.lineTo(150*Je1[0], -150*Je1[1]); ctx2.stroke();
    ctx2.beginPath(); ctx2.moveTo(-150*Je2[0], 150*Je2[1]); ctx2.lineTo(150*Je2[0], -150*Je2[1]); ctx2.stroke();
    ctx2.globalAlpha = 1;
    ctx2.fillStyle = getColor('accent-red');
    ctx2.fillText('x̃¹', 150*Je1[0] + 5, -150*Je1[1] + 5);
    ctx2.fillText('x̃²', 150*Je2[0] + 5, -150*Je2[1] + 5);

    // choose the same data you used on the left (same units so numbers match your Θ(V) display):
    // covector components p = (p, 0), projected vector π_*V = (vx, 0)
    const pVec = [p, 0];
    const dxVec = [vx, 0];

    // original Θ = p · dx  (scaled like your left readout: divide by 100)
    const thetaOrig = (pVec[0]*dxVec[0] + pVec[1]*dxVec[1]) / 100;

    // transformed data:
    //  vectors by J, covectors by (J^{-1})^T
    const pTilde  = mul(JinvT, pVec);
    const dxTilde = mul(J,    dxVec);
    const thetaTilde = (pTilde[0]*dxTilde[0] + pTilde[1]*dxTilde[1]) / 100;

    // draw the two vectors (blue in original frame, red in transformed frame)
    const disp = 0.6; // on-canvas display scale
    // original dx (blue)
    ctx2.strokeStyle = getColor('accent-blue'); ctx2.lineWidth = 3;
    ctx2.beginPath(); ctx2.moveTo(0,0); ctx2.lineTo(disp*dxVec[0], -disp*dxVec[1]); ctx2.stroke();

    // transformed dx~ (red)
    ctx2.strokeStyle = getColor('accent-red'); ctx2.lineWidth = 3;
    ctx2.beginPath(); ctx2.moveTo(0,0); ctx2.lineTo(disp*dxTilde[0], -disp*dxTilde[1]); ctx2.stroke();

    // info panel
    const diff = Math.abs(thetaOrig - thetaTilde);
    ctx2.fillStyle = 'rgba(255,255,255,0.06)';
    ctx2.fillRect(-170, 60, 340, 92);
    ctx2.strokeStyle = getColor('glass-border'); ctx2.strokeRect(-170, 60, 340, 92);

    ctx2.fillStyle = getColor('text-primary'); ctx2.font = '12px monospace'; ctx2.textAlign = 'left';
    ctx2.fillText(`Original:   Θ = ${thetaOrig.toFixed(6)}`,  -160,  85);
    ctx2.fillText(`Transformed Θ̃ = ${thetaTilde.toFixed(6)}`, -160, 105);
    ctx2.fillText(`|Θ−Θ̃| = ${diff.toExponential(2)}`,         -160, 125);

    ctx2.textAlign = 'center'; ctx2.font = 'bold 14px monospace';
    if (diff < 1e-10) {
      ctx2.fillStyle = getColor('accent-green'); ctx2.fillText('✓ INVARIANT', 0, 140);
    } else {
      ctx2.fillStyle = getColor('accent-red');   ctx2.fillText('✗ ERROR', 0, 140);
    }

    ctx2.restore();

    requestAnimationFrame(draw);
  }

  document.getElementById('ctrl-2-angle').addEventListener('input', draw);
  document.getElementById('ctrl-2-phase').addEventListener('input', draw);
  draw();
})();

        // Part 3: COMPLETELY NEW IMPLEMENTATION MATCHING THE ASSIGNMENT
(function() {
    const ctx1 = setupCanvas('viz-3a');
    const ctx2 = setupCanvas('viz-3b');
    let isAnimating = false;
    let animTime = 0;
    let energyHistory = [];
    let areaHistory = [];
    
    function draw() {
        const system = document.getElementById('ctrl-3-system').value;
        let time = parseFloat(document.getElementById('ctrl-3-time').value) / 50;
        
        if (isAnimating) {
            animTime += 0.02;
            time = animTime % 6;
            document.getElementById('ctrl-3-time').value = time * 50;
        }
        
        document.getElementById('val-3-time').textContent = time.toFixed(2);
        
        const canvas1 = ctx1.canvas;
        const canvas2 = ctx2.canvas;
        const w1 = canvas1.width / (window.devicePixelRatio || 1);
        const h1 = canvas1.height / (window.devicePixelRatio || 1);
        const w2 = canvas2.width / (window.devicePixelRatio || 1);
        const h2 = canvas2.height / (window.devicePixelRatio || 1);
        
        ctx1.clearRect(0, 0, w1, h1);
        ctx2.clearRect(0, 0, w2, h2);
        
        // LEFT PANEL: Show X_H vector field and trajectories
        ctx1.save();
        ctx1.translate(w1/2, h1/2);
        
        // Draw the Hamiltonian vector field X_H = ∂H/∂p ∂/∂x - ∂H/∂x ∂/∂p
        ctx1.globalAlpha = 0.3;
        for (let i = -8; i <= 8; i += 2) {
            for (let j = -8; j <= 8; j += 2) {
                const x = i * 20;
                const p = j * 20;
                
                let dx = 0, dp = 0;
                
                if (system === 'harmonic') {
                    // H = 1/2(p² + x²)
                    // ∂H/∂p = p, ∂H/∂x = x
                    // X_H = p∂_x - x∂_p
                    dx = p;
                    dp = -x;
                } else if (system === 'anharmonic') {
                    // H = 1/2 p² + 1/4 x⁴
                    // ∂H/∂p = p, ∂H/∂x = x³
                    const x_normalized = x / 60; // Consistent scaling with level curves
                    dx = p;
                    dp = -Math.pow(x_normalized, 3) * 60; // Proper scaling back to pixel coordinates
                } else if (system === 'pendulum') {
                    // H = 1/2 p² - cos(x)
                    // ∂H/∂p = p, ∂H/∂x = sin(x)
                    dx = p;
                    dp = -Math.sin(x/40) * 40;
                }
                
                // Normalize and draw
                const mag = Math.sqrt(dx*dx + dp*dp);
                if (mag > 0.1) {
                    const scale = Math.min(15, 300/mag);
                    dx = scale * dx / mag;
                    dp = scale * dp / mag;
                    
                    ctx1.strokeStyle = 'rgba(255,255,255,0.25)';
                    ctx1.lineWidth = 1;
                    ctx1.beginPath();
                    ctx1.moveTo(x, -p);
                    ctx1.lineTo(x + dx, -p - dp);
                    ctx1.stroke();
                    
                    // Arrowhead
                    ctx1.save();
                    ctx1.translate(x + dx, -p - dp);
                    ctx1.rotate(Math.atan2(-dp, dx));
                    ctx1.fillStyle = 'rgba(255,255,255,0.25)';
                    ctx1.beginPath();
                    ctx1.moveTo(0, 0);
                    ctx1.lineTo(-3, 2);
                    ctx1.lineTo(-3, -2);
                    ctx1.fill();
                    ctx1.restore();
                }
            }
        }
        ctx1.globalAlpha = 1;
        
        // Draw level curves H = const
        ctx1.strokeStyle = 'rgba(66, 133, 244, 0.2)';
        ctx1.lineWidth = 1;
        
        if (system === 'harmonic') {
            // Circles: H = 1/2(p² + x²) = E
            for (let E = 0.5; E <= 3; E += 0.5) {
                const r = Math.sqrt(2 * E) * 60;
                ctx1.beginPath();
                ctx1.arc(0, 0, r, 0, 2 * Math.PI);
                ctx1.stroke();
            }
        } else if (system === 'anharmonic') {
            // Curves for H = 1/2 p² + 1/4 x⁴ = E
            for (let E = 0.2; E <= 2; E += 0.4) {
                ctx1.beginPath();
                for (let x = -150; x <= 150; x += 2) {
                    const x_normalized = x / 60;
                    const p_squared = 2 * (E - 0.25 * Math.pow(x_normalized, 4));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        if (x === -150) {
                            ctx1.moveTo(x, -p);
                        } else {
                            ctx1.lineTo(x, -p);
                        }
                    }
                }
                ctx1.stroke();
                
                ctx1.beginPath();
                for (let x = -150; x <= 150; x += 2) {
                    const x_normalized = x / 60;
                    const p_squared = 2 * (E - 0.25 * Math.pow(x_normalized, 4));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        if (x === -150) {
                            ctx1.moveTo(x, p);
                        } else {
                            ctx1.lineTo(x, p);
                        }
                    }
                }
                ctx1.stroke();
            }
        } else if (system === 'pendulum') {
            // Phase portrait for pendulum
            for (let E = -0.8; E <= 2; E += 0.4) {
                ctx1.beginPath();
                for (let x = -3.14; x <= 3.14; x += 0.05) {
                    const p_squared = 2 * (E + Math.cos(x));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        ctx1.lineTo(x * 60, -p);
                    }
                }
                ctx1.stroke();
                
                ctx1.beginPath();
                for (let x = -3.14; x <= 3.14; x += 0.05) {
                    const p_squared = 2 * (E + Math.cos(x));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        ctx1.lineTo(x * 60, p);
                    }
                }
                ctx1.stroke();
            }
        }
        
        // Draw trajectories
        const colors = [
            getColor('accent-blue'),
            getColor('accent-green'),
            getColor('accent-yellow'),
            getColor('accent-red')
        ];
        
        let maxDeltaH = 0;
        
        for (let k = 0; k < 4; k++) {
            ctx1.strokeStyle = colors[k];
            ctx1.lineWidth = 2.5;
            ctx1.globalAlpha = 0.9;
            
            ctx1.beginPath();
            
            // Initial conditions
            let x, p;
            if (system === 'harmonic') {
                const r0 = 60 + k * 20;
                const theta0 = k * Math.PI / 2;
                x = r0 * Math.cos(theta0) / 60;
                p = r0 * Math.sin(theta0) / 60;
            } else if (system === 'anharmonic') {
                x = (k - 1.5) * 0.5;
                p = 1.0 - k * 0.2;
            } else {
                x = (k - 1.5) * 0.8;
                p = 0.5 + k * 0.1;
            }
            
            // Calculate initial energy
            let H0;
            if (system === 'harmonic') {
                H0 = 0.5 * (p*p + x*x);
            } else if (system === 'anharmonic') {
                H0 = 0.5 * p*p + 0.25 * Math.pow(x, 4);
            } else {
                H0 = 0.5 * p*p - Math.cos(x);
            }
            
            // Integrate using Runge-Kutta 4
            const dt = 0.005;
            const steps = Math.floor(time / dt);
            
            for (let step = 0; step <= steps; step++) {
                // Draw trajectory
                if (step % 10 === 0) {
                    if (step === 0) ctx1.moveTo(x * 60, -p * 60);
                    else ctx1.lineTo(x * 60, -p * 60);
                }
                
                // RK4 step
                let k1x, k1p, k2x, k2p, k3x, k3p, k4x, k4p;
                
                if (system === 'harmonic') {
                    k1x = p;
                    k1p = -x;
                    
                    k2x = p + 0.5*dt*k1p;
                    k2p = -(x + 0.5*dt*k1x);
                    
                    k3x = p + 0.5*dt*k2p;
                    k3p = -(x + 0.5*dt*k2x);
                    
                    k4x = p + dt*k3p;
                    k4p = -(x + dt*k3x);
                } else if (system === 'anharmonic') {
                    k1x = p;
                    k1p = -Math.pow(x, 3);
                    
                    k2x = p + 0.5*dt*k1p;
                    k2p = -Math.pow(x + 0.5*dt*k1x, 3);
                    
                    k3x = p + 0.5*dt*k2p;
                    k3p = -Math.pow(x + 0.5*dt*k2x, 3);
                    
                    k4x = p + dt*k3p;
                    k4p = -Math.pow(x + dt*k3x, 3);
                } else {
                    k1x = p;
                    k1p = -Math.sin(x);
                    
                    k2x = p + 0.5*dt*k1p;
                    k2p = -Math.sin(x + 0.5*dt*k1x);
                    
                    k3x = p + 0.5*dt*k2p;
                    k3p = -Math.sin(x + 0.5*dt*k2x);
                    
                    k4x = p + dt*k3p;
                    k4p = -Math.sin(x + dt*k3x);
                }
                
                x += dt * (k1x + 2*k2x + 2*k3x + k4x) / 6;
                p += dt * (k1p + 2*k2p + 2*k3p + k4p) / 6;
                
                // Calculate energy
                let H;
                if (system === 'harmonic') {
                    H = 0.5 * (p*p + x*x);
                } else if (system === 'anharmonic') {
                    H = 0.5 * p*p + 0.25 * Math.pow(x, 4);
                } else {
                    H = 0.5 * p*p - Math.cos(x);
                }
                
                maxDeltaH = Math.max(maxDeltaH, Math.abs(H - H0));
            }
            
            ctx1.stroke();
            ctx1.globalAlpha = 1;
            
            // Mark current position
            ctx1.fillStyle = colors[k];
            ctx1.beginPath();
            ctx1.arc(x * 60, -p * 60, 4, 0, 2 * Math.PI);
            ctx1.fill();
        }
        
        // Calculate divergence numerically: div(X_H) = ∂(∂H/∂p)/∂x + ∂(-∂H/∂x)/∂p
        function calculateDivergence(system, x, p) {
            if (system === 'harmonic') {
                // X_H = p∂_x - x∂_p → div = ∂(p)/∂x + ∂(-x)/∂p = 0 + 0 = 0
                return 0;
            } else if (system === 'anharmonic') {
                // X_H = p∂_x - x³∂_p → div = ∂(p)/∂x + ∂(-x³)/∂p = 0 + 0 = 0  
                return 0;
            } else if (system === 'pendulum') {
                // X_H = p∂_x - sin(x)∂_p → div = ∂(p)/∂x + ∂(-sin(x))/∂p = 0 + 0 = 0
                return 0;
            }
            return 0;
        }

        // Compute max divergence across sample points
        let maxDiv = 0;
        for (let i = -8; i <= 8; i += 4) {
            for (let j = -8; j <= 8; j += 4) {
                const x = i * 20;
                const p = j * 20;
                const div = calculateDivergence(system, x, p);
                maxDiv = Math.max(maxDiv, Math.abs(div));
            }
        }
        
        document.getElementById('delta-h').textContent = maxDeltaH.toFixed(6);
        document.getElementById('div-xh').textContent = maxDiv.toFixed(6);
        
        ctx1.restore();
        
        // RIGHT PANEL: Show conservation properties
        ctx2.save();
        ctx2.translate(w2/2, h2/2);
        
        // Title
        ctx2.fillStyle = getColor('text-primary');
        ctx2.font = 'bold 14px monospace';
        ctx2.textAlign = 'center';
        ctx2.fillText('Verification of Conservation Laws', 0, -160);
        
        // Draw a test region evolution to show area preservation
        const testRegion = [];
        const N = 20;
        for (let i = 0; i < N; i++) {
            const angle = 2 * Math.PI * i / N;
            testRegion.push({
                x: 0.5 + 0.2 * Math.cos(angle),
                p: 0.5 + 0.2 * Math.sin(angle)
            });
        }
        
        // Draw initial region
        ctx2.fillStyle = 'rgba(66, 133, 244, 0.3)';
        ctx2.strokeStyle = getColor('accent-blue');
        ctx2.lineWidth = 2;
        ctx2.beginPath();
        for (let i = 0; i <= N; i++) {
            const pt = testRegion[i % N];
            if (i === 0) ctx2.moveTo(pt.x * 100, -pt.p * 100);
            else ctx2.lineTo(pt.x * 100, -pt.p * 100);
        }
        ctx2.fill();
        ctx2.stroke();
        
        // Evolve the region
        const evolvedRegion = [];
        for (let pt of testRegion) {
            let x = pt.x;
            let p = pt.p;
            
            // Integrate forward in time
            const dt = 0.01;
            const steps = Math.floor(time / dt);
            
            for (let step = 0; step < steps; step++) {
                let dx, dp;
                if (system === 'harmonic') {
                    dx = p;
                    dp = -x;
                } else if (system === 'anharmonic') {
                    dx = p;
                    dp = -Math.pow(x, 3);
                } else {
                    dx = p;
                    dp = -Math.sin(x);
                }
                x += dx * dt;
                p += dp * dt;
            }
            
            evolvedRegion.push({ x, p });
        }
        
        // Draw evolved region
        ctx2.fillStyle = 'rgba(234, 67, 53, 0.3)';
        ctx2.strokeStyle = getColor('accent-red');
        ctx2.beginPath();
        for (let i = 0; i <= N; i++) {
            const pt = evolvedRegion[i % N];
            if (i === 0) ctx2.moveTo(pt.x * 100, -pt.p * 100);
            else ctx2.lineTo(pt.x * 100, -pt.p * 100);
        }
        ctx2.fill();
        ctx2.stroke();
        
        // Calculate areas (Shoelace formula)
        function calculateArea(region) {
            let area = 0;
            for (let i = 0; i < region.length; i++) {
                const j = (i + 1) % region.length;
                area += region[i].x * region[j].p - region[j].x * region[i].p;
            }
            return Math.abs(area) / 2;
        }
        
        const area0 = calculateArea(testRegion);
        const area1 = calculateArea(evolvedRegion);
        const areaRatio = area1 / area0;
        
        // Display results
        ctx2.fillStyle = getColor('text-primary');
        ctx2.font = '12px monospace';
        ctx2.textAlign = 'left';
        ctx2.fillText('Initial Area:', -160, 120);
        ctx2.fillText(`A₀ = ${area0.toFixed(4)}`, -160, 140);
        
        ctx2.fillText('Final Area:', 20, 120);
        ctx2.fillText(`A(t) = ${area1.toFixed(4)}`, 20, 140);
        
        ctx2.textAlign = 'center';
        ctx2.font = 'bold 14px monospace';
        ctx2.fillStyle = getColor('accent-green');
        ctx2.fillText(`Area Ratio = ${areaRatio.toFixed(6)}`, 0, 170);
        ctx2.fillText('✓ ℒ_Xₕ(ω) = 0', 0, -130);
        
        ctx2.restore();
        
        if (isAnimating) {
            requestAnimationFrame(draw);
        }
    }
    
    document.getElementById('btn-3-animate').addEventListener('click', () => {
        isAnimating = !isAnimating;
        document.getElementById('btn-3-animate').textContent = isAnimating ? 'Stop' : 'Animate Flow';
        document.getElementById('btn-3-animate').classList.toggle('active', isAnimating);
        if (isAnimating) draw();
    });
    
    document.getElementById('btn-3-reset').addEventListener('click', () => {
        animTime = 0;
        energyHistory = [];
        areaHistory = [];
        document.getElementById('ctrl-3-time').value = 0;
        isAnimating = false;
        document.getElementById('btn-3-animate').textContent = 'Animate Flow';
        document.getElementById('btn-3-animate').classList.remove('active');
        draw();
    });
    
    document.getElementById('ctrl-3-system').addEventListener('change', () => {
        energyHistory = [];
        areaHistory = [];
        draw();
    });
    
    document.getElementById('ctrl-3-time').addEventListener('input', () => {
        if (!isAnimating) draw();
    });
    
    draw();
})();
        // Part 4: Poisson Bracket
        (function() {
            const ctx1 = setupCanvas('viz-4a');
            const ctx2 = setupCanvas('viz-4b');
            
            function draw() {
                const f = document.getElementById('ctrl-4-f').value;
                const g = document.getElementById('ctrl-4-g').value;
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Bracket geometry
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw level sets of f
                ctx1.strokeStyle = getColor('accent-blue');
                ctx1.lineWidth = 1.5;
                ctx1.globalAlpha = 0.6;
                
                if (f === 'x') {
                    for (let x = -150; x <= 150; x += 30) {
                        ctx1.beginPath();
                        ctx1.moveTo(x, -180);
                        ctx1.lineTo(x, 180);
                        ctx1.stroke();
                    }
                } else if (f === 'p') {
                    for (let p = -150; p <= 150; p += 30) {
                        ctx1.beginPath();
                        ctx1.moveTo(-180, -p);
                        ctx1.lineTo(180, -p);
                        ctx1.stroke();
                    }
                } else if (f === 'L') {
                    // Hyperbolas for angular momentum
                    for (let c = -100; c <= 100; c += 50) {
                        if (c !== 0) {
                            ctx1.beginPath();
                            for (let x = -150; x <= 150; x += 5) {
                                const y = c / x;
                                if (Math.abs(y) < 150) {
                                    if (x === -150) ctx1.moveTo(x, -y);
                                    else ctx1.lineTo(x, -y);
                                }
                            }
                            ctx1.stroke();
                        }
                    }
                } else if (f === 'H') {
                    for (let r = 40; r <= 120; r += 40) {
                        ctx1.beginPath();
                        ctx1.arc(0, 0, r, 0, 2 * Math.PI);
                        ctx1.stroke();
                    }
                }
                
                ctx1.globalAlpha = 1;
                
                // Draw Hamiltonian vector field of g
                ctx1.strokeStyle = getColor('accent-red');
                ctx1.lineWidth = 1;
                
                for (let i = -6; i <= 6; i += 2) {
                    for (let j = -6; j <= 6; j += 2) {
                        const x = i * 30;
                        const p = j * 30;
                        
                        let dx = 0, dp = 0;
                        
                        if (g === 'p') {
                            dx = 1;
                            dp = 0;
                        } else if (g === 'x') {
                            dx = 0;
                            dp = -1;
                        } else if (g === 'L') {
                            dx = -p / 30;
                            dp = x / 30;
                        } else if (g === 'H') {
                            dx = p / 30;
                            dp = -x / 30;
                        }
                        
                        const scale = 20;
                        dx *= scale;
                        dp *= scale;
                        
                        if (dx !== 0 || dp !== 0) {
                            ctx1.beginPath();
                            ctx1.moveTo(x, -p);
                            ctx1.lineTo(x + dx, -p - dp);
                            ctx1.stroke();
                            
                            // Arrow
                            ctx1.save();
                            ctx1.translate(x + dx, -p - dp);
                            ctx1.rotate(Math.atan2(-dp, dx));
                            ctx1.fillStyle = getColor('accent-red');
                            ctx1.beginPath();
                            ctx1.moveTo(0, 0);
                            ctx1.lineTo(-5, 2);
                            ctx1.lineTo(-5, -2);
                            ctx1.fill();
                            ctx1.restore();
                        }
                    }
                }
                
                // Calculate bracket value
                let bracketValue = 'complex';
                if (f === 'x' && g === 'p') bracketValue = '1';
                else if (f === 'p' && g === 'x') bracketValue = '-1';
                else if (f === g) bracketValue = '0';
                else if (f === 'x' && g === 'L') bracketValue = 'y';
                else if (f === 'p' && g === 'L') bracketValue = '-p_y';
                else if ((f === 'L' || f === 'H') && (g === 'L' || g === 'H')) bracketValue = '0';
                
                document.getElementById('bracket-result').textContent = bracketValue;
                
                ctx1.restore();
                
                // Jacobi identity visualization
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                const time = Date.now() / 3000;
                
                // Three functions in cyclic symmetry
                const functions = ['f', 'g', 'h'];
                const colors = [
                    getColor('accent-blue'),
                    getColor('accent-green'),
                    getColor('accent-red')
                ];
                
                for (let i = 0; i < 3; i++) {
                    const angle = (i * 2 * Math.PI / 3) + time;
                    const x = 80 * Math.cos(angle);
                    const y = 80 * Math.sin(angle);
                    
                    // Draw vector
                    ctx2.strokeStyle = colors[i];
                    ctx2.lineWidth = 3;
                    ctx2.beginPath();
                    ctx2.moveTo(0, 0);
                    ctx2.lineTo(x, y);
                    ctx2.stroke();
                    
                    // Draw circle at end
                    ctx2.fillStyle = colors[i];
                    ctx2.beginPath();
                    ctx2.arc(x, y, 8, 0, 2 * Math.PI);
                    ctx2.fill();
                    
                    // Label
                    ctx2.fillStyle = getColor('text-primary');
                    ctx2.font = 'bold 16px monospace';
                    ctx2.fillText(functions[i], x * 1.3, y * 1.3);
                }
                
                // Draw cycling triangle
                ctx2.strokeStyle = 'rgba(255,255,255,0.2)';
                ctx2.lineWidth = 1;
                ctx2.setLineDash([5, 5]);
                ctx2.beginPath();
                for (let i = 0; i <= 3; i++) {
                    const angle = (i * 2 * Math.PI / 3) + time;
                    const x = 80 * Math.cos(angle);
                    const y = 80 * Math.sin(angle);
                    if (i === 0) ctx2.moveTo(x, y);
                    else ctx2.lineTo(x, y);
                }
                ctx2.stroke();
                ctx2.setLineDash([]);
                
                // Jacobi formula
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '12px monospace';
                ctx2.textAlign = 'center';
                ctx2.fillText('Σ cyclic = 0', 0, 140);
                
                ctx2.restore();
                
                requestAnimationFrame(draw);
            }
            
            document.getElementById('ctrl-4-f').addEventListener('change', draw);
            document.getElementById('ctrl-4-g').addEventListener('change', draw);
            
            draw();
        })();

        // Part 5: Euler Field
        (function() {
            const ctx1 = setupCanvas('viz-5a');
            const ctx2 = setupCanvas('viz-5b');
            let isAnimating = false;
            
            function draw() {
                let t = parseFloat(document.getElementById('ctrl-5-t').value) / 100;
                
                if (isAnimating) {
                    t = Math.sin(Date.now() / 1000) * 2;
                    document.getElementById('ctrl-5-t').value = t * 100;
                }
                
                document.getElementById('val-5-t').textContent = t.toFixed(2);
                const scale = Math.exp(t);
                document.getElementById('val-5-scale').textContent = scale.toFixed(3);
                document.getElementById('volume-scale').textContent = scale.toFixed(3);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Euler field visualization
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw fiber structure
                ctx1.strokeStyle = 'rgba(255,255,255,0.1)';
                ctx1.lineWidth = 1;
                for (let x = -150; x <= 150; x += 50) {
                    ctx1.beginPath();
                    ctx1.moveTo(x, -180);
                    ctx1.lineTo(x, 180);
                    ctx1.stroke();
                }
                
                // Base manifold Q
                ctx1.strokeStyle = getColor('accent-green');
                ctx1.lineWidth = 2;
                ctx1.beginPath();
                ctx1.moveTo(-180, 0);
                ctx1.lineTo(180, 0);
                ctx1.stroke();
                
                // Draw Euler vector field E = p ∂/∂p
                ctx1.strokeStyle = getColor('accent-yellow');
                ctx1.lineWidth = 1.5;
                
                for (let i = -3; i <= 3; i++) {
                    for (let j = -6; j <= 6; j++) {
                        if (j === 0) continue;
                        
                        const x = i * 50;
                        const p = j * 30;
                        
                        // E points radially in p direction
                        const dp = p * 0.3;
                        
                        ctx1.beginPath();
                        ctx1.moveTo(x, -p);
                        ctx1.lineTo(x, -p - dp);
                        ctx1.stroke();
                        
                        // Arrow
                        if (Math.abs(dp) > 10) {
                            ctx1.save();
                            ctx1.translate(x, -p - dp);
                            ctx1.fillStyle = getColor('accent-yellow');
                            ctx1.beginPath();
                            ctx1.moveTo(0, 0);
                            ctx1.lineTo(-3, dp > 0 ? 5 : -5);
                            ctx1.lineTo(3, dp > 0 ? 5 : -5);
                            ctx1.fill();
                            ctx1.restore();
                        }
                        
                        // Show scaled points
                        const scaledP = p * scale;
                        if (Math.abs(scaledP) < 180) {
                            ctx1.fillStyle = `rgba(66, 133, 244, ${0.5 + 0.3 * Math.sin(Date.now() / 500 + i + j)})`;
                            ctx1.beginPath();
                            ctx1.arc(x, -scaledP, 4, 0, 2 * Math.PI);
                            ctx1.fill();
                        }
                    }
                }
                
                ctx1.restore();
                
                // Symplectic scaling visualization
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                // Original symplectic form (area element)
                const w = 80;
                const h = 60;
                
                ctx2.fillStyle = 'rgba(66, 133, 244, 0.3)';
                ctx2.strokeStyle = getColor('accent-blue');
                ctx2.lineWidth = 2;
                ctx2.fillRect(-w/2, -h/2, w, h);
                ctx2.strokeRect(-w/2, -h/2, w, h);
                
                // Scaled symplectic form
                const scaledH = h * scale;
                ctx2.fillStyle = 'rgba(234, 67, 53, 0.3)';
                ctx2.strokeStyle = getColor('accent-red');
                ctx2.fillRect(-w/2, -scaledH/2, w, scaledH);
                ctx2.strokeRect(-w/2, -scaledH/2, w, scaledH);
                
                // Labels
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '14px monospace';
                ctx2.textAlign = 'center';
                ctx2.fillText('ω', 0, -h/2 - 20);
                ctx2.fillText(`e^t·ω`, 0, -scaledH/2 - 20);
                
                // Show the scaling relationship
                ctx2.strokeStyle = getColor('accent-yellow');
                ctx2.lineWidth = 2;
                ctx2.setLineDash([5, 5]);
                ctx2.beginPath();
                ctx2.moveTo(-w/2, 0);
                ctx2.lineTo(-w/2 - 30, 0);
                ctx2.moveTo(-w/2 - 30, -h/2);
                ctx2.lineTo(-w/2 - 30, h/2);
                ctx2.stroke();
                
                ctx2.beginPath();
                ctx2.moveTo(-w/2 - 50, 0);
                ctx2.lineTo(-w/2 - 80, 0);
                ctx2.moveTo(-w/2 - 80, -scaledH/2);
                ctx2.lineTo(-w/2 - 80, scaledH/2);
                ctx2.stroke();
                ctx2.setLineDash([]);
                
                ctx2.restore();
                
                if (isAnimating) {
                    requestAnimationFrame(draw);
                }
            }
            
            document.getElementById('btn-5-animate').addEventListener('click', () => {
                isAnimating = !isAnimating;
                document.getElementById('btn-5-animate').textContent = isAnimating ? 'Stop Scaling' : 'Animate Scaling';
                document.getElementById('btn-5-animate').classList.toggle('active', isAnimating);
                if (isAnimating) draw();
            });
            
            document.getElementById('ctrl-5-t').addEventListener('input', () => {
                if (!isAnimating) draw();
            });
            
            draw();
        })();
    </script>
</body>
</html>
