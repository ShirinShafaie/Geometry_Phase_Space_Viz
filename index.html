<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>The Geometry of Phase Space | An Interactive Journey Through T*Q</title>
    
    <!-- KaTeX for math rendering -->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body, {delimiters: [{left: '$$', right: '$$', display: true}, {left: '$', right: '$', display: false}]});"></script>

    <style>
        :root {
            --golden: 1.618033988749;
            --bg-primary: #0a0e27;
            --bg-secondary: #151933;
            --bg-tertiary: #1e2341;
            --text-primary: #e8eaed;
            --text-secondary: #9aa0a6;
            --accent-blue: #4285f4;
            --accent-green: #34a853;
            --accent-yellow: #fbbc04;
            --accent-red: #ea4335;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-border: rgba(255, 255, 255, 0.1);
            --shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            background: linear-gradient(135deg, var(--bg-primary) 0%, var(--bg-secondary) 100%);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            line-height: 1.6;
            overflow-x: hidden;
            min-height: 100vh;
        }

        /* Animated background */
        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: radial-gradient(circle at 20% 50%, rgba(66, 133, 244, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 80% 80%, rgba(52, 168, 83, 0.1) 0%, transparent 50%),
                        radial-gradient(circle at 40% 20%, rgba(234, 67, 53, 0.1) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
            animation: drift 20s ease-in-out infinite;
        }

        @keyframes drift {
            0%, 100% { transform: translate(0, 0) rotate(0deg); }
            33% { transform: translate(-20px, -20px) rotate(1deg); }
            66% { transform: translate(20px, -10px) rotate(-1deg); }
        }

        /* Header with glassmorphism */
        .header {
            position: sticky;
            top: 0;
            z-index: 1000;
            background: var(--glass);
            backdrop-filter: blur(20px);
            -webkit-backdrop-filter: blur(20px);
            border-bottom: 1px solid var(--glass-border);
            padding: 2rem;
            text-align: center;
            animation: slideDown 0.8s ease-out;
        }

        @keyframes slideDown {
            from { transform: translateY(-100%); opacity: 0; }
            to { transform: translateY(0); opacity: 1; }
        }

        .header h1 {
            font-size: 2.5em;
            font-weight: 300;
            letter-spacing: 2px;
            background: linear-gradient(90deg, var(--accent-blue), var(--accent-green), var(--accent-yellow));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            animation: shimmer 3s ease-in-out infinite;
        }

        @keyframes shimmer {
            0%, 100% { filter: brightness(1); }
            50% { filter: brightness(1.2); }
        }

        .header p {
            margin-top: 0.5rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        /* Navigation dots */
        .nav-dots {
            position: fixed;
            right: 2rem;
            top: 50%;
            transform: translateY(-50%);
            z-index: 999;
        }

        .nav-dot {
            display: block;
            width: 12px;
            height: 12px;
            margin: 20px 0;
            border-radius: 50%;
            background: var(--glass);
            border: 2px solid var(--glass-border);
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .nav-dot.active {
            background: var(--accent-blue);
            border-color: var(--accent-blue);
            box-shadow: 0 0 20px var(--accent-blue);
        }

        .nav-dot:hover {
            transform: scale(1.5);
        }

        /* Main container */
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
            position: relative;
            z-index: 1;
        }

        /* Section cards with glassmorphism */
        .section {
            background: var(--glass);
            backdrop-filter: blur(10px);
            border: 1px solid var(--glass-border);
            border-radius: 20px;
            padding: 3rem;
            margin: 3rem 0;
            box-shadow: var(--shadow);
            opacity: 0;
            transform: translateY(50px);
            animation: fadeInUp 0.8s ease-out forwards;
        }

        .section:nth-child(1) { animation-delay: 0.2s; }
        .section:nth-child(2) { animation-delay: 0.4s; }
        .section:nth-child(3) { animation-delay: 0.6s; }
        .section:nth-child(4) { animation-delay: 0.8s; }
        .section:nth-child(5) { animation-delay: 1.0s; }

        @keyframes fadeInUp {
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .section-header {
            margin-bottom: 2rem;
        }

        .section-number {
            display: inline-block;
            width: 40px;
            height: 40px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            text-align: center;
            line-height: 40px;
            border-radius: 50%;
            font-weight: bold;
            margin-right: 1rem;
        }

        .section h2 {
            display: inline-block;
            font-size: 1.8em;
            font-weight: 400;
        }

        /* Mathematical insight boxes */
        .insight {
            background: linear-gradient(135deg, rgba(66, 133, 244, 0.1), rgba(52, 168, 83, 0.1));
            border-left: 4px solid var(--accent-blue);
            padding: 1.5rem;
            margin: 2rem 0;
            border-radius: 10px;
            position: relative;
            overflow: hidden;
        }

        .insight::before {
            content: '💡';
            position: absolute;
            top: 1rem;
            right: 1rem;
            font-size: 2em;
            opacity: 0.3;
        }

        .insight h3 {
            color: var(--accent-blue);
            margin-bottom: 0.5rem;
        }

        /* Visualisation containers */
        .viz-container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 2rem;
            margin: 2rem 0;
        }

        @media (max-width: 768px) {
            .viz-container {
                grid-template-columns: 1fr;
            }
        }

        .viz-panel {
            background: var(--bg-tertiary);
            border: 1px solid var(--glass-border);
            border-radius: 15px;
            overflow: hidden;
            position: relative;
        }

        .viz-title {
            background: linear-gradient(90deg, var(--bg-secondary), var(--bg-tertiary));
            padding: 1rem;
            font-weight: 500;
            text-align: center;
            border-bottom: 1px solid var(--glass-border);
            font-family: 'Courier New', monospace;
        }

        canvas {
            display: block;
            width: 100%;
            height: 400px;
            background: var(--bg-primary);
        }

        /* Controls with modern styling */
        .controls {
            background: var(--bg-secondary);
            padding: 1.5rem;
            border-top: 1px solid var(--glass-border);
        }

        .control-group {
            margin: 1rem 0;
        }

        .control-group label {
            display: block;
            margin-bottom: 0.5rem;
            color: var(--text-secondary);
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        input[type="range"] {
            width: 100%;
            height: 6px;
            background: var(--glass);
            border-radius: 3px;
            outline: none;
            -webkit-appearance: none;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            border-radius: 50%;
            cursor: pointer;
            box-shadow: 0 0 10px rgba(66, 133, 244, 0.5);
            transition: all 0.3s ease;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.8);
        }

        .button {
            background: linear-gradient(135deg, var(--accent-blue), var(--accent-green));
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s ease;
            margin: 0.5rem;
            box-shadow: 0 4px 15px rgba(66, 133, 244, 0.3);
        }

        .button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 20px rgba(66, 133, 244, 0.5);
        }

        .button.active {
            background: linear-gradient(135deg, var(--accent-red), var(--accent-yellow));
        }

        /* Result display */
        .result {
            background: var(--bg-tertiary);
            border: 1px solid var(--accent-blue);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            font-family: 'Courier New', monospace;
            text-align: center;
            font-size: 1.2em;
            box-shadow: 0 0 20px rgba(66, 133, 244, 0.2);
        }

        .result .value {
            color: var(--accent-green);
            font-weight: bold;
        }

        /* Mathematical notation */
        .math-display {
            background: var(--bg-tertiary);
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-radius: 10px;
            border: 1px solid var(--glass-border);
            overflow-x: auto;
        }

        /* Loading animation */
        .loading {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: var(--bg-primary);
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10000;
            animation: fadeOut 1s ease-out 2s forwards;
        }

        @keyframes fadeOut {
            to { opacity: 0; pointer-events: none; }
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 3px solid var(--glass);
            border-top-color: var(--accent-blue);
            border-radius: 50%;
            animation: spin 1s ease-in-out infinite;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }
    </style>
<style>
  /* Part 4 layout */
  #pb4 #pb4-geo { height: 420px; }
  #pb4 #pb4-vectors { height: 300px; }

  .pb4-legend{
    display:flex; flex-wrap:wrap; gap:.5rem; padding:.75rem 1rem .25rem;
    border-bottom:1px solid var(--glass-border); background:var(--bg-tertiary);
  }

  .chip{
    display:inline-block; padding:.25rem .6rem; border-radius:999px;
    font-size:.8rem; letter-spacing:.3px; border:1px solid var(--glass-border);
    background:var(--glass);
  }
  .chip-blue   { border-color: rgba(66,133,244,.5); box-shadow: 0 0 10px rgba(66,133,244,.12) inset; }
  .chip-green  { border-color: rgba(52,168,83,.5);  box-shadow: 0 0 10px rgba(52,168,83,.12) inset; }
  .chip-violet { border-color: rgba(179,136,255,.5);box-shadow: 0 0 10px rgba(179,136,255,.12) inset; }
  .chip-amber  { border-color: rgba(251,188,4,.5);  box-shadow: 0 0 10px rgba(251,188,4,.12) inset; }

  .kpi-grid{
    display:grid; grid-template-columns: 1fr auto; gap:10px 16px;
    padding:1rem 1.25rem; background: var(--bg-tertiary);
    border-top:1px solid var(--glass-border); border-bottom:1px solid var(--glass-border);
  }
  .kpi-grid > div:nth-child(2n){
    text-align:right; font-family: "Courier New", monospace; color: var(--accent-green);
  }

  .mini-line{ margin-top:.35rem; font-family:"Courier New", monospace; }
</style>
</head>
<body>
    <!-- Loading screen -->
    <div class="loading">
        <div class="loading-spinner"></div>
    </div>

    <!-- Navigation dots -->
    <div class="nav-dots">
        <span class="nav-dot active" data-section="1"></span>
        <span class="nav-dot" data-section="2"></span>
        <span class="nav-dot" data-section="3"></span>
        <span class="nav-dot" data-section="4"></span>
        <span class="nav-dot" data-section="5"></span>
    </div>

    <div class="header">
        <h1>The Geometry of Phase Space</h1>
        <p>An Interactive Journey Through the Cotangent Bundle T*Q</p>
    </div>

    <div class="container"><!-- Context box -->
<div class="insight" id="context">
  <h3>Context</h3>
  <p>
    We have an $n$-dimensional manifold $Q$ with coordinates $(x^1,\dots,x^n)$.
    The cotangent bundle $T^*Q$ is a $2n$-dimensional manifold with coordinates
    $(x^1,\dots,x^n,\, p_1,\dots,p_n)$, where $p$ are the canonically conjugate
    momenta. In these coordinates, the bundle projection
    $\pi: T^*Q \to Q$ has the expression $\pi(x,p)=x$.
  </p>
</div>

        <!-- Section 1: Coordinate Transformations -->
        <div class="section" data-section-id="1">
            <div class="section-header">
                <span class="section-number">1</span>
                <h2>Coordinate Transformation of Conjugate Momenta</h2>
            </div>

            <div class="math-display">
  $$\textbf{Given: }\ \tilde{x}=f(x)\ \text{ with Jacobian }\ 
    J^i{}_{j}=\frac{\partial \tilde{x}^i}{\partial x^j}$$
  $$\textbf{Covector transformation (contragredient) law: }\ 
    \tilde{p}_i = p_j\,(J^{-1})^j{}_{i}
    = p_j\,\frac{\partial x^j}{\partial \tilde{x}^i}$$
</div>
            <div class="insight">
                <h3>The Duality Principle</h3>
                <p>When position coordinates transform by a matrix $A$, momentum coordinates transform by $(A^{-1})^T$. This inverse–transpose behaviour ensures that the fundamental pairing $p \cdot dx$ remains invariant: a cornerstone of Hamiltonian mechanics.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Configuration Space Q</div>
                    <canvas id="viz-1a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Cotangent Fibers T*Q</div>
                    <canvas id="viz-1b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Rotation θ: <span id="val-1-theta">0°</span></label>
                    <input type="range" id="ctrl-1-theta" min="-90" max="90" value="0">
                </div>
                <div class="control-group">
                    <label>x-shear k: <span id="val-1-shear">0.00</span></label>
                    <input type="range" id="ctrl-1-shear" min="-100" max="100" value="0">
                </div>
                <div class="control-group">
                    <label>Scale σ: <span id="val-1-scale">1.00</span></label>
                    <input type="range" id="ctrl-1-scale" min="50" max="200" value="100">
                </div>
            </div>
<div class="insight" id="notes-1">
  <h3>Quick Guide</h3>
  <ul style="margin-top:0.25rem">
    <li><strong>What changes:</strong> coordinates transform by the Jacobian 
      $J^i{}_j=\dfrac{\partial \tilde{x}^i}{\partial x^j}$ (rotate / scale / shear)
    </li>
    <li><strong>What co-changes:</strong> covectors (momenta) transform by the inverse transpose:
      $\ \tilde p_i = p_j\,(J^{-1})^j{}_i$
    </li>
    <li><strong>Why:</strong> to keep the canonical pairing $p_i\,dx^i$ invariant:
      $$p_i\,dx^i=\tilde p_i\,d\tilde x^i \quad\Longleftrightarrow\quad \tilde p_i = p_j\,(J^{-1})^j{}_i$$
    </li>
  </ul>
</div>
        </div>

        <!-- Section 2: Canonical 1-form -->
        <div class="section" data-section-id="2">
            <div class="section-header">
                <span class="section-number">2</span>
                <h2>The Canonical 1-form Θ</h2>
            </div>

            <div class="math-display">
                $$\Theta_{(x,p)}(V) = p(\pi_* V) \quad \text{where} \quad \Theta = p_i dx^i$$
            </div>

            <div class="insight">
                <h3>The Tautological Structure</h3>
                <p>The canonical 1-form Θ is "tautological" because it encodes the very definition of the cotangent bundle. At each point $(x,p)$, it evaluates a vector by taking its base projection and pairing it with the fiber coordinate—the momentum itself acts as the linear functional.</p>
            </div>

            <div class="viz-container">
                <div class="viz-panel">
                    <div class="viz-title">Θ Acting on Vectors</div>
                    <canvas id="viz-2a"></canvas>
                </div>
                <div class="viz-panel">
                    <div class="viz-title">Coordinate Invariance</div>
                    <canvas id="viz-2b"></canvas>
                </div>
            </div>

            <div class="controls">
                <div class="control-group">
                    <label>Vector Angle: <span id="val-2-angle">45°</span></label>
                    <input type="range" id="ctrl-2-angle" min="0" max="360" value="45">
                </div>
                <div class="control-group">
                    <label>Phase Point: <span id="val-2-phase">50</span></label>
                    <input type="range" id="ctrl-2-phase" min="0" max="100" value="50">
                </div>
            </div>

            <div class="result">
                Θ(V) = <span class="value" id="theta-result">0.00</span>
            </div>
<div class="insight" id="sec2-quick-guide">
  <h3>Quick Guide — Coordinate Invariance of Θ</h3>
  <ul>
    <li><strong>Definition:</strong> 
      $\,\Theta_{(x,p)}(V)=p(\pi_*V)=p_i\,dx^i(V)\,$
    </li>
    <li><strong>Change of coordinates:</strong> 
      $\,\tilde x^i=f^i(x)$ with Jacobian 
      $\,J^i{}_j=\dfrac{\partial\tilde x^i}{\partial x^j}\,$
    </li>
    <li><strong>Transformation laws:</strong> 
      $\,d\tilde x^i=J^i{}_j\,dx^j,\qquad 
      \tilde p_i=p_j\,(J^{-1})^j{}_i\,$
    </li>
    <li><strong>Invariance:</strong> 
      $\,\tilde p_i\,d\tilde x^i
      =p_j\,(J^{-1})^j{}_i\,J^i{}_k\,dx^k
      =p_k\,dx^k\,$
    </li>
    <li><strong>1D check (this panel):</strong> 
      $\,J=\dfrac{d\tilde x}{dx},\ \tilde p=\dfrac{p}{J},\ 
      d\tilde x(V)=J\,dx(V)\ \Rightarrow\ 
      \Theta(V)=\tilde\Theta(V)\,$
    </li>
  </ul>
</div>
<div class="insight" id="notes-2">
  <h3>Direct Algebraic Verification</h3>
  <p>From Section 1, we have the transformation laws:</p>
  <div class="math-display">
    $$\tilde{p}_i = p_j \frac{\partial x^j}{\partial \tilde{x}^i}, \quad d\tilde{x}^i = \frac{\partial \tilde{x}^i}{\partial x^k} dx^k$$
  </div>
  <p>Substituting into the transformed 1-form:</p>
  <div class="math-display">
    $$\begin{aligned}
    \tilde{p}_i d\tilde{x}^i &= \left(p_j \frac{\partial x^j}{\partial \tilde{x}^i}\right) \left(\frac{\partial \tilde{x}^i}{\partial x^k} dx^k\right) \\
    &= p_j \left(\frac{\partial x^j}{\partial \tilde{x}^i} \frac{\partial \tilde{x}^i}{\partial x^k}\right) dx^k \\
    &= p_j \delta^j_k dx^k \quad \text{(chain rule)} \\
    &= p_j dx^j \\
    &= p_i dx^i
    \end{aligned}$$
  </div>
  <p>This proves the coordinate invariance of the canonical 1-form Θ.</p>
</div>
        </div>

        <!-- Section 3: Hamiltonian Vector Fields -->
<div class="section" data-section-id="3">
    <div class="section-header">
        <span class="section-number">3</span>
        <h2>Hamiltonian Vector Fields and Symmetries</h2>
    </div>

    <div class="math-display">
  $$\omega = dp_i\wedge dx^i,\qquad V \mapsto i_V(\omega)=(dp_i(V))\,dx^i-(dx^i(V))\,dp_i$$
  $$H \mapsto X_H = -\,\omega^{-1} dH
    = \big(-\partial_{x^i}H\big)\,\partial_{p_i}
      + \big(\partial_{p_i}H\big)\,\partial_{x^i}$$
</div>

    <div class="insight">
        <h3>Infinitesimal Symmetries</h3>
        <p>Verify that $X_H$ is an infinitesimal symmetry of both $\omega$ and $H$:</p>
        <ul style="list-style-type: none; padding-left: 0;">
            <li><strong>1.</strong> $\mathcal{L}_{X_H}\omega = 0$ — The symplectic form is preserved</li>
            <li><strong>2.</strong> $\mathcal{L}_{X_H}H = 0$ — Energy is conserved along the flow</li>
        </ul>
        <p>These two properties encode the fundamental conservation laws of Hamiltonian mechanics.</p>
    </div>

    <div class="viz-container">
        <div class="viz-panel">
            <div class="viz-title">Hamiltonian Flow & Vector Field X_H</div>
            <canvas id="viz-3a"></canvas>
        </div>
        <div class="viz-panel">
            <div class="viz-title">Conservation Verification</div>
            <canvas id="viz-3b"></canvas>
        </div>
    </div>

    <div class="controls">
        <div class="control-group">
            <label>Hamiltonian System</label>
            <select id="ctrl-3-system" class="button" style="width: 100%; text-align: left;">
                <option value="harmonic">Harmonic Oscillator: H = ½(p² + x²)</option>
                <option value="anharmonic">Anharmonic: H = ½p² + ¼x⁴</option>
                <option value="pendulum">Pendulum: H = ½p² - cos(x)</option>
            </select>
        </div>
        <div class="control-group">
            <label>Evolution Time: <span id="val-3-time">0.00</span></label>
            <input type="range" id="ctrl-3-time" min="0" max="300" value="0">
        </div>
        <button class="button" id="btn-3-animate">Animate Flow</button>
        <button class="button" id="btn-3-reset">Reset</button>
    </div>

     <div class="result">
        <div>Max |ΔH|: <span class="value" id="delta-h">0.000000</span></div>
        <div>Max |div(X_H)|: <span class="value" id="div-xh">0.000000</span></div>
        <div>Area ratio A(t)/A₀: <span class="value" id="area-ratio">1.000000</span></div>
      </div>

<div class="insight" id="sec3-numerics">
  <h3>How we achieve machine-precision area preservation</h3>
  <ul style="margin-top:.25rem">
    <li><strong>Symplectic time stepping:</strong> the right panel advects points with the
      <em>Störmer–Verlet</em> (leapfrog) scheme, a second-order <em>symplectic</em> integrator.
      Symplectic methods preserve the canonical 2-form $\,\omega=dp_i\wedge dx^i\,$ (area in the $x$–$p$ plane) up to roundoff, avoiding the secular drift typical of non-symplectic schemes.</li>
    <li><strong>Polygon advection:</strong> we evolve a closed polygon of $N=60$ vertices and compute its area with the shoelace formula <em>in the $(x,p)$ coordinates</em>. Larger $N$ reduces discretization error on curved boundaries.</li>
    <li><strong>Step size & rounding:</strong> a small fixed $dt$ (many short steps) keeps local truncation errors tiny; any residual deviation is floating-point roundoff and canvas rendering, typically $10^{-12}$–$10^{-14}$ in the area ratio for the default settings.</li>
    <li><strong>Why not plain Euler?</strong> forward Euler is not symplectic and introduces area drift.
      For the linear harmonic oscillator it can <em>look</em> fine at very small $dt$, but for the anharmonic and pendulum systems the drift becomes visible. Störmer–Verlet fixes this across all three.</li>
    <li><strong>Separation of $T(p)$ and $V(x)$:</strong> these Hamiltonians are separable, $H=T(p)+V(x)$. Störmer–Verlet alternates exact updates for the $T$-flow and the $V$-flow; the composition is symplectic and keeps area invariant up to machine precision.</li>
  </ul>
</div>

<div class="insight" id="sec3-insight">
  <h3>Quick Guide: Why $\mathcal{L}_{X_H}\omega = 0$ and $\mathcal{L}_{X_H}H = 0$</h3>

  <p style="margin-top:.5rem">
    <strong>Cartan’s formula:</strong> $\ \mathcal{L}_{X_H}\omega = d\!\left(i_{X_H}\omega\right)+i_{X_H}(d\omega)$.
    Since $i_{X_H}\omega=-\,dH$ and $d\omega=0$, we get $\ \mathcal{L}_{X_H}\omega=d(-dH)+0=0$.
  </p>

  <div class="math-display" style="margin-top:1rem">
    $$\omega = dp_i \wedge dx^i,\qquad V \longmapsto i_V(\omega)=(dp_i(V))\,dx^i-(dx^i(V))\,dp_i$$
    $$H \mapsto X_H = -\,\omega^{-1} dH
      = \big(-\partial_{x^i}H\big)\,\partial_{p_i}
        + \big(\partial_{p_i}H\big)\,\partial_{x^i}$$
  </div>

  <div class="math-display" style="margin-top:1rem">
    $$\mathcal{L}_{X_H}H = X_H(H) = \frac{\partial H}{\partial p_i}\frac{\partial H}{\partial x^i}
      - \frac{\partial H}{\partial x^i}\frac{\partial H}{\partial p_i} = 0$$
  </div>

  <p style="margin-top:1rem">
    <strong>How to read the plots:</strong> the left panel draws $X_H$ and sample trajectories (level sets of $H$);
    the right panel evolves a region to show area preservation (Liouville).
  </p>
</div>

       <!-- Section 4: Poisson Bracket -->
<div class="section" data-section-id="4">
  <div class="section-header">
    <span class="section-number">4</span>
    <h2>The Poisson Bracket Algebra</h2>
  </div>

  <!-- Box 1: definition + Hamiltonian vector field (coordinate-free first) -->
  <div class="math-display">
    $$\textbf{Convention:}\quad i_{X_f}\omega=-\,df,\qquad
      \omega=\sum_{i=1}^n dp_i\wedge dx^i$$

    $$\Rightarrow\quad
      \omega(X_f,\cdot)=-\,df(\cdot),\qquad
      \{f,g\}:=X_g(f)=-\,X_f(g)=-\,\omega(X_f,X_g)$$

    $$\text{Canonical coordinates:}\quad
      X_f=\sum_{i=1}^n\!\left(
        \frac{\partial f}{\partial p_i}\,\partial_{x^i}
        -\frac{\partial f}{\partial x^i}\,\partial_{p_i}
      \right)$$
  </div>

  <!-- Box 2: coordinate formula + identities -->
  <div class="insight">
    <h3>Quick Guide</h3>

    <div class="math-display" style="margin-top:.5rem">
      $$\{f,g\}=\sum_{i=1}^n\!\left(
          \frac{\partial f}{\partial x^i}\frac{\partial g}{\partial p_i}
          -\frac{\partial f}{\partial p_i}\frac{\partial g}{\partial x^i}
        \right),
        \qquad \{x^i,p_j\}=\delta^i{}_j$$
    </div>

    <div class="math-display" style="margin-top:.75rem">
  $$
  \begin{aligned}
  \text{Jacobi identity (cyclic expression):}\quad
  &\{f,\{g,h\}\}+\{g,\{h,f\}\}+\{h,\{f,g\}\}=0\\[6pt]
  \text{Anti-homomorphism:}\quad
  &X_{\{f,g\}}=-\,[X_f,X_g]
  \end{aligned}
  $$
</div>


 <!-- ======== PART 4 ======== -->
<div class="viz-container" id="pb4">
  <!-- LEFT: geometry -->
  <div class="viz-panel">
    <div class="viz-title">Level Sets of f & Field X_g</div>
    <canvas id="pb4-geo"></canvas>

    <div class="controls">
      <div class="control-group">
        <label>f(x,p)</label>
        <select id="pb4-f" class="button" style="width:100%">
          <option value="x">x</option>
          <option value="p">p</option>
          <option value="xp">x·p</option>
          <option value="Hx">H = ½(p² + x²)</option>
          <option value="x2">½ x²</option>
          <option value="p2">½ p²</option>
          <option value="sinx">sin x</option>
          <option value="cosx">cos x</option>
        </select>
      </div>

      <div class="control-group">
        <label>g(x,p)</label>
        <select id="pb4-g" class="button" style="width:100%">
          <option value="p">p</option>
          <option value="x">x</option>
          <option value="xp">x·p</option>
          <option value="Hx">H = ½(p² + x²)</option>
          <option value="x2">½ x²</option>
          <option value="p2">½ p²</option>
          <option value="sinx">sin x</option>
          <option value="cosx">cos x</option>
        </select>
      </div>
    </div>
  </div>

  <!-- RIGHT: vector lab (single canvas, external legend, tidy KPIs) -->
  <div class="viz-panel">
    <div class="viz-title">Vector Lab at (x₀,p₀)</div>
    <div class="pb4-legend">
      <span class="chip chip-blue">X_f</span>
      <span class="chip chip-green">X_g</span>
      <span class="chip chip-violet">X_{ {f,g} }</span>
      <span class="chip chip-amber">±[X_f, X_g]</span>
    </div>
    <canvas id="pb4-vectors"></canvas>

    <div class="kpi-grid">
      <div>Skew {f,g}+{g,f}</div>              <div id="pb4-skew">—</div>
      <div>Jacobi residual J(f,g,h)</div>      <div id="pb4-jacobi">—</div>
      <div>Homomorphism ‖X_{ {f,g} } ∓ [X_f,X_g]‖</div> <div id="pb4-homo">—</div>
      <div>Coordinate invariance |{f,g} − {f̃,g̃}|</div> <div id="pb4-inv">—</div>
    </div>

    <div class="controls">
      <div class="control-group">
        <label>h(x,p)</label>
        <select id="pb4-h" class="button" style="width:100%">
          <option value="Hx">H = ½(p² + x²)</option>
          <option value="x">x</option>
          <option value="p">p</option>
          <option value="xp">x·p</option>
          <option value="x2">½ x²</option>
          <option value="p2">½ p²</option>
          <option value="sinx">sin x</option>
          <option value="cosx">cos x</option>
        </select>
      </div>

      <div class="control-group">
        <label>Evaluation point (x₀, p₀)</label>
        <input type="range" id="pb4-x0" min="-200" max="200" value="60">
        <input type="range" id="pb4-p0" min="-200" max="200" value="80">
        <div class="mini-line">
          x₀ = <span id="pb4-x0-val">0.60</span>, p₀ = <span id="pb4-p0-val">0.80</span>
        </div>
      </div>

      <div class="control-group">
        <label>Scaling (cotangent lift):  x̃ = σ x ,  p̃ = p/σ</label>
        <input type="range" id="pb4-sigma" min="20" max="200" value="130">
        <div class="mini-line">σ = <span id="pb4-sigma-val">1.30</span></div>
      </div>

      <div class="control-group">
        <label>Poisson convention</label>
        <button id="pb4-conv" class="button" title="Toggle Poisson sign">
          Current: {f,g} = ∂f/∂x ∂g/∂p − ∂f/∂p ∂g/∂x
        </button>
        <div class="mini-line" style="color:var(--text-secondary)">
          “∓” in the homomorphism flips with the convention.
        </div>
      </div>
    </div>
  </div>
</div>

       <!-- Section 5: Euler–Liouville Field -->
<div class="section" data-section-id="5">
  <div class="section-header">
    <span class="section-number">5</span>
    <h2>The Euler–Liouville Field</h2>
  </div>

  <div class="math-display">
  $$E \;=\; p_1 \frac{\partial}{\partial p_1} \;+\; \cdots \;+\; p_n \frac{\partial}{\partial p_n}$$
  $$\varphi_t^E(x,p) \;=\; (\,x,\, e^t p\,)$$
</div>

  <!-- Euler field form in any canonical coordinates -->
<div class="insight">
  <h3>Euler Field in Any Canonical Coordinates</h3>
  <p>In canonical coordinates $(\tilde x,\tilde p)$ with $\tilde p_i = p_j\,(J^{-1})^j{}_i$, the Euler field keeps exactly the same index-by-index form:</p>
  <div class="math-display" style="margin-top:.5rem">
    $$E \;=\; p_1 \frac{\partial}{\partial p_1} \;+\; \cdots \;+\; p_n \frac{\partial}{\partial p_n}
      \;=\; \tilde p_1 \frac{\partial}{\partial \tilde p_1} \;+\; \cdots \;+\; \tilde p_n \frac{\partial}{\partial \tilde p_n}$$
  </div>
</div>

  <div class="viz-container">
    <div class="viz-panel">
      <div class="viz-title">Fiber Dilation Flow φᵗᴱ</div>
      <canvas id="viz-5a"></canvas>
    </div>
    <div class="viz-panel">
      <div class="viz-title">Verification Panel</div>
      <canvas id="viz-5b"></canvas>
    </div>
  </div>

  <div class="controls">
    <div class="control-group">
      <label>Flow Parameter t: <span id="val-5-t">0.00</span></label>
      <input type="range" id="ctrl-5-t" min="-200" max="200" value="0">
    </div>
    <div class="control-group">
      <label>Verification Mode</label>
      <select id="ctrl-5-mode" class="button" style="width:100%">
        <option value="scaling">ω-scaling: (φ_t^E)*ω = e^t · ω</option>
        <option value="contraction">Contraction: i_E(ω) = Θ</option>
        <option value="liouville">Liouville: ℒ_E ω = ω</option>
        <option value="coordinate">Coordinate form of E</option>
      </select>
    </div>
    <button class="button" id="btn-5-animate">Animate Flow</button>
  </div>

  <div class="result">
    <div>Scale e^t: <span class="value" id="scale-5">1.000</span></div>
    <div id="verification-5">Verification: <span class="value">Exact</span></div>
  </div>

  <div class="insight">
  <h3>Liouville Property</h3>

  <p><strong>Contraction:</strong> $i_E\omega=\Theta$:</p>
  <div class="math-display">
    $$\omega \;=\; dp_i \wedge dx^i,\qquad
      i_E dp_i \;=\; E(p_i) \;=\; p_i,\qquad
      i_E dx^i \;=\; E(x^i) \;=\; 0$$
    $$\Rightarrow\quad i_E\omega
      \;=\; (i_E dp_i)\,dx^i \;-\; dp_i\wedge(i_E dx^i)
      \;=\; p_i\,dx^i \;=\; \Theta$$
  </div>

  <p><strong>Lie derivative:</strong></p>
  <div class="math-display">
    $$L_E(\omega) \;=\; d\,(i_E\omega) \;+\; i_E(d\omega)
      \;=\; d\Theta \;+\; 0
      \;=\; \omega$$
  </div>

  <p><strong>Pullback by the flow:</strong> under $\varphi_t^E(x,p)=(x,e^t p)$,</p>
  <div class="math-display">
    $$(\varphi_t^E)^*(dp_i\wedge dx^i)
      \;=\; d(e^t p_i)\wedge dx^i
      \;=\; e^t\,dp_i\wedge dx^i
      \;=\; e^t\,\omega$$
  </div>
</div>

    <script>
        // Utility functions
        function getColor(name) {
            const style = getComputedStyle(document.documentElement);
            return style.getPropertyValue(`--${name}`).trim();
        }

        // Smooth scrolling for navigation dots
        document.querySelectorAll('.nav-dot').forEach(dot => {
            dot.addEventListener('click', () => {
                const section = document.querySelector(`.section[data-section-id="${dot.dataset.section}"]`);
                section.scrollIntoView({ behavior: 'smooth' });
            });
        });

        // Update active navigation dot on scroll
        window.addEventListener('scroll', () => {
            const sections = document.querySelectorAll('.section');
            const dots = document.querySelectorAll('.nav-dot');
            
            sections.forEach((section, index) => {
                const rect = section.getBoundingClientRect();
                if (rect.top <= window.innerHeight / 2 && rect.bottom >= window.innerHeight / 2) {
                    dots.forEach(d => d.classList.remove('active'));
                    dots[index].classList.add('active');
                }
            });
        });

        // Canvas setup with high DPI support
        function setupCanvas(id) {
            const canvas = document.getElementById(id);
            const ctx = canvas.getContext('2d');
            const dpr = window.devicePixelRatio || 1;
            const rect = canvas.getBoundingClientRect();
            canvas.width = rect.width * dpr;
            canvas.height = rect.height * dpr;
            ctx.scale(dpr, dpr);
            return ctx;
        }

        // Part 1: Coordinate Transformations
        (function() {
            const ctx1 = setupCanvas('viz-1a');
            const ctx2 = setupCanvas('viz-1b');
            
            function draw() {
                const theta = parseFloat(document.getElementById('ctrl-1-theta').value) * Math.PI / 180;
                const shear = parseFloat(document.getElementById('ctrl-1-shear').value) / 100;
                const scale = parseFloat(document.getElementById('ctrl-1-scale').value) / 100;
                
                document.getElementById('val-1-theta').textContent = (theta * 180 / Math.PI).toFixed(0) + '°';
                document.getElementById('val-1-shear').textContent = shear.toFixed(2);
                document.getElementById('val-1-scale').textContent = scale.toFixed(2);
                
                const canvas1 = ctx1.canvas;
                const canvas2 = ctx2.canvas;
                const w1 = canvas1.width / (window.devicePixelRatio || 1);
                const h1 = canvas1.height / (window.devicePixelRatio || 1);
                const w2 = canvas2.width / (window.devicePixelRatio || 1);
                const h2 = canvas2.height / (window.devicePixelRatio || 1);
                
                // Clear canvases
                ctx1.clearRect(0, 0, w1, h1);
                ctx2.clearRect(0, 0, w2, h2);
                
                // Configuration space
                ctx1.save();
                ctx1.translate(w1/2, h1/2);
                
                // Draw original grid
                ctx1.strokeStyle = getColor('accent-blue');
                ctx1.lineWidth = 1;
                ctx1.globalAlpha = 0.5;
                for (let i = -5; i <= 5; i++) {
                    ctx1.beginPath();
                    ctx1.moveTo(i * 30, -150);
                    ctx1.lineTo(i * 30, 150);
                    ctx1.stroke();
                    ctx1.beginPath();
                    ctx1.moveTo(-150, i * 30);
                    ctx1.lineTo(150, i * 30);
                    ctx1.stroke();
                }
                ctx1.globalAlpha = 1;
                
                // Draw transformed grid
                ctx1.save();
                ctx1.rotate(theta);
                ctx1.scale(scale, scale);
                ctx1.transform(1, 0, shear, 1, 0, 0);
                
                ctx1.strokeStyle = getColor('accent-red');
                ctx1.lineWidth = 1.5;
                ctx1.globalAlpha = 0.7;
                for (let i = -5; i <= 5; i++) {
                    ctx1.beginPath();
                    ctx1.moveTo(i * 30, -150);
                    ctx1.lineTo(i * 30, 150);
                    ctx1.stroke();
                    ctx1.beginPath();
                    ctx1.moveTo(-150, i * 30);
                    ctx1.lineTo(150, i * 30);
                    ctx1.stroke();
                }
                ctx1.restore();
                
                // Labels
                ctx1.fillStyle = getColor('text-primary');
                ctx1.font = '14px monospace';
                ctx1.fillText('x¹', 160, 5);
                ctx1.fillText('x²', 5, -160);
                
                ctx1.restore();
                
                // Cotangent space (inverse–transpose)
                ctx2.save();
                ctx2.translate(w2/2, h2/2);
                
                // Original momentum grid
                ctx2.strokeStyle = getColor('accent-blue');
                ctx2.lineWidth = 1;
                ctx2.globalAlpha = 0.5;
                for (let i = -5; i <= 5; i++) {
                    ctx2.beginPath();
                    ctx2.moveTo(i * 30, -150);
                    ctx2.lineTo(i * 30, 150);
                    ctx2.stroke();
                    ctx2.beginPath();
                    ctx2.moveTo(-150, i * 30);
                    ctx2.lineTo(150, i * 30);
                    ctx2.stroke();
                }
                ctx2.globalAlpha = 1;
                
                // Contragredient transformation (inverse transpose)
                ctx2.save();
        	const invScale = 1 / scale;  
                
                ctx2.rotate(theta);
                ctx2.scale(invScale, invScale);
                ctx2.transform(1, -shear, 0, 1, 0, 0);
                
                ctx2.strokeStyle = getColor('accent-red');
                ctx2.lineWidth = 1.5;
                ctx2.globalAlpha = 0.7;
                for (let i = -5; i <= 5; i++) {
                    ctx2.beginPath();
                    ctx2.moveTo(i * 30, -150);
                    ctx2.lineTo(i * 30, 150);
                    ctx2.stroke();
                    ctx2.beginPath();
                    ctx2.moveTo(-150, i * 30);
                    ctx2.lineTo(150, i * 30);
                    ctx2.stroke();
                }
                ctx2.restore();
                
                // Draw sample momentum vectors
                const vectors = [[80, 30], [-60, 50], [40, -70]];
                vectors.forEach(([px, py]) => {
                    // Original
                    ctx2.strokeStyle = getColor('accent-blue');
                    ctx2.lineWidth = 2;
                    ctx2.beginPath();
                    ctx2.moveTo(0, 0);
                    ctx2.lineTo(px, -py);
                    ctx2.stroke();
                    
                    // Transformed by (J^{-1})^T = R(+θ) · S(1/σ) · [[1,0],[-k,1]]
// 1) y-shear with −k
let qx = px;
let qy = -shear * px + py;

// 2) scale by 1/σ
qx *= invScale;
qy *= invScale;

// 3) rotate by +θ
const c = Math.cos(theta), s = Math.sin(theta);
const px_new = c * qx - s * qy;
const py_new = s * qx + c * qy;

ctx2.strokeStyle = getColor('accent-red');
ctx2.beginPath();
ctx2.moveTo(0, 0);
ctx2.lineTo(px_new, -py_new);
ctx2.stroke();
                });
                
                // Labels
                ctx2.fillStyle = getColor('text-primary');
                ctx2.font = '14px monospace';
                ctx2.fillText('p₁', 160, 5);
                ctx2.fillText('p₂', 5, -160);
                
                ctx2.restore();
                
                requestAnimationFrame(draw);
            }
            
            document.getElementById('ctrl-1-theta').addEventListener('input', draw);
            document.getElementById('ctrl-1-shear').addEventListener('input', draw);
            document.getElementById('ctrl-1-scale').addEventListener('input', draw);
            
            draw();
        })();

        // Part 2: Canonical 1-form  — upgraded right panel (numeric invariance check)
(function () {
  const ctx1 = setupCanvas('viz-2a');
  const ctx2 = setupCanvas('viz-2b');

  // small linear-algebra helpers (2×2)
  function mat(a,b,c,d){ return [[a,b],[c,d]]; }
  function mul(A,v){ return [A[0][0]*v[0] + A[0][1]*v[1], A[1][0]*v[0] + A[1][1]*v[1]]; }
  function invT(A){
    const [a,b] = A[0], [c,d] = A[1];
    const det = a*d - b*c;
    // (A^{-1})^T = 1/det * [[d, -c], [-b, a]]
    return [[ d/det, -c/det],
            [-b/det,  a/det]];
  }
  function rotScale(alpha, sigma){
    const c = Math.cos(alpha), s = Math.sin(alpha);
    // J = sigma * R(alpha)
    return mat(sigma*c, -sigma*s, sigma*s, sigma*c);
  }
  function draw() {
    
    const angle = parseFloat(document.getElementById('ctrl-2-angle').value) * Math.PI / 180;
    const phase = parseFloat(document.getElementById('ctrl-2-phase').value);

    document.getElementById('val-2-angle').textContent = (angle * 180 / Math.PI).toFixed(0) + '°';
    document.getElementById('val-2-phase').textContent = phase.toFixed(0);

    const w1 = ctx1.canvas.width / (window.devicePixelRatio || 1);
    const h1 = ctx1.canvas.height / (window.devicePixelRatio || 1);
    const w2 = ctx2.canvas.width / (window.devicePixelRatio || 1);
    const h2 = ctx2.canvas.height / (window.devicePixelRatio || 1);

    ctx1.clearRect(0, 0, w1, h1);
    ctx2.clearRect(0, 0, w2, h2);

    // ---------- LEFT PANEL: Θ acting on vectors ----------
    ctx1.save();
    ctx1.translate(w1/2, h1/2);

    // base line Q
    ctx1.strokeStyle = getColor('glass-border');
    ctx1.lineWidth = 1;
    ctx1.beginPath();
    ctx1.moveTo(-180, 100);
    ctx1.lineTo(180, 100);
    ctx1.stroke();

    // fibers
    for (let x = -150; x <= 150; x += 50) {
      ctx1.strokeStyle = 'rgba(255,255,255,0.1)';
      ctx1.beginPath(); ctx1.moveTo(x, 100); ctx1.lineTo(x, -150); ctx1.stroke();
    }

    const x = phase * 2 - 100;   // [-100,100]
    const p = 80;                 // momentum magnitude
    ctx1.fillStyle = getColor('accent-yellow');
    ctx1.beginPath(); ctx1.arc(x, -p, 6, 0, 2*Math.PI); ctx1.fill();

    const vx = 70 * Math.cos(angle);
    const vy = 70 * Math.sin(angle);

    // tangent vector V
    ctx1.strokeStyle = getColor('accent-blue');
    ctx1.lineWidth = 3;
    ctx1.beginPath(); ctx1.moveTo(x, -p); ctx1.lineTo(x + vx, -p + vy); ctx1.stroke();
    ctx1.save();
    ctx1.translate(x + vx, -p + vy);
    ctx1.rotate(Math.atan2(vy, vx));
    ctx1.fillStyle = getColor('accent-blue');
    ctx1.beginPath(); ctx1.moveTo(0, 0); ctx1.lineTo(-8, 4); ctx1.lineTo(-8, -4); ctx1.fill();
    ctx1.restore();

    // projection π_*V to Q
    ctx1.strokeStyle = getColor('accent-green');
    ctx1.lineWidth = 2;
    ctx1.setLineDash([5,5]);
    ctx1.beginPath(); ctx1.moveTo(x, -p); ctx1.lineTo(x, 100); ctx1.stroke();
    ctx1.setLineDash([]);
    ctx1.beginPath(); ctx1.moveTo(x, 100); ctx1.lineTo(x + vx, 100); ctx1.stroke();

    // labels
    ctx1.fillStyle = getColor('text-primary');
    ctx1.font = '12px monospace';
    ctx1.fillText('(x,p)', x + 10, -p);
    ctx1.fillText('V',     x + vx + 10, -p + vy);
    ctx1.fillText('π_*V',  x + vx + 10, 105);
    ctx1.fillText('Q', -175, 95);

    // original Θ(V) readout (consistent with scaling)
    const thetaLeft = (p * vx) / 100;
    document.getElementById('theta-result').textContent = thetaLeft.toFixed(3);

    ctx1.restore();

    // ---------- RIGHT PANEL: numeric verification p·dx = p~·dx~ ----------
    ctx2.save();
    ctx2.translate(w2/2, h2/2);

    // animated coordinate change  x̃ = J x  with  J = σ R(α)
    const t = Date.now() / 1200;
    const alpha = 0.9 * Math.sin(t);                 // rotation
    const sigma = 1.2 + 0.3 * Math.sin(0.7 * t);     // isotropic scale
    const J = rotScale(alpha, sigma);
    const JinvT = invT(J);

    // draw original axes (blue)
    ctx2.strokeStyle = getColor('accent-blue');
    ctx2.lineWidth = 2; ctx2.globalAlpha = 0.9;
    ctx2.beginPath(); ctx2.moveTo(-150, 0); ctx2.lineTo(150, 0); ctx2.stroke();
    ctx2.beginPath(); ctx2.moveTo(0, -150); ctx2.lineTo(0, 150); ctx2.stroke();
    ctx2.globalAlpha = 1;
    ctx2.fillStyle = getColor('accent-blue');
    ctx2.font = '12px monospace';
    ctx2.fillText('x¹', 155, 5); ctx2.fillText('x²', 5, -155);

    // draw transformed axes (red)
    const e1 = [1,0], e2 = [0,1];
    const Je1 = mul(J, e1), Je2 = mul(J, e2);
    ctx2.strokeStyle = getColor('accent-red'); ctx2.lineWidth = 2; ctx2.globalAlpha = 0.8;
    ctx2.beginPath(); ctx2.moveTo(-150*Je1[0], 150*Je1[1]); ctx2.lineTo(150*Je1[0], -150*Je1[1]); ctx2.stroke();
    ctx2.beginPath(); ctx2.moveTo(-150*Je2[0], 150*Je2[1]); ctx2.lineTo(150*Je2[0], -150*Je2[1]); ctx2.stroke();
    ctx2.globalAlpha = 1;
    ctx2.fillStyle = getColor('accent-red');
    ctx2.fillText('x̃¹', 150*Je1[0] + 5, -150*Je1[1] + 5);
    ctx2.fillText('x̃²', 150*Je2[0] + 5, -150*Je2[1] + 5);

    // same data as the left (same units so numbers match Θ(V) display):
    // covector components p = (p, 0), projected vector π_*V = (vx, 0)
    const pVec = [p, 0];
    const dxVec = [vx, 0];

    // original Θ = p · dx  (scaled like your left readout: divide by 100)
    const thetaOrig = (pVec[0]*dxVec[0] + pVec[1]*dxVec[1]) / 100;

    // transformed data:
    //  vectors by J, covectors by (J^{-1})^T
    const pTilde  = mul(JinvT, pVec);
    const dxTilde = mul(J,    dxVec);
    const thetaTilde = (pTilde[0]*dxTilde[0] + pTilde[1]*dxTilde[1]) / 100;

    // draw the two vectors (blue in original frame, red in transformed frame)
    const disp = 0.6; // on-canvas display scale
    // original dx (blue)
    ctx2.strokeStyle = getColor('accent-blue'); ctx2.lineWidth = 3;
    ctx2.beginPath(); ctx2.moveTo(0,0); ctx2.lineTo(disp*dxVec[0], -disp*dxVec[1]); ctx2.stroke();

    // transformed dx~ (red)
    ctx2.strokeStyle = getColor('accent-red'); ctx2.lineWidth = 3;
    ctx2.beginPath(); ctx2.moveTo(0,0); ctx2.lineTo(disp*dxTilde[0], -disp*dxTilde[1]); ctx2.stroke();

    // info panel
    const diff = Math.abs(thetaOrig - thetaTilde);
    ctx2.fillStyle = 'rgba(255,255,255,0.06)';
    ctx2.fillRect(-170, 60, 340, 92);
    ctx2.strokeStyle = getColor('glass-border'); ctx2.strokeRect(-170, 60, 340, 92);

    ctx2.fillStyle = getColor('text-primary'); ctx2.font = '12px monospace'; ctx2.textAlign = 'left';
    ctx2.fillText(`Original:   Θ = ${thetaOrig.toFixed(6)}`,  -160,  85);
    ctx2.fillText(`Transformed Θ̃ = ${thetaTilde.toFixed(6)}`, -160, 105);
    ctx2.fillText(`|Θ−Θ̃| = ${diff.toExponential(2)}`,         -160, 125);

    ctx2.textAlign = 'center'; ctx2.font = 'bold 14px monospace';
    if (diff < 1e-10) {
      ctx2.fillStyle = getColor('accent-green'); ctx2.fillText('✓ INVARIANT', 0, 140);
    } else {
      ctx2.fillStyle = getColor('accent-red');   ctx2.fillText('✗ ERROR', 0, 140);
    }

    ctx2.restore();

    requestAnimationFrame(draw);
  }

  document.getElementById('ctrl-2-angle').addEventListener('input', draw);
  document.getElementById('ctrl-2-phase').addEventListener('input', draw);
  draw();
})();

        // Part 3: NEW IMPLEMENTATION
(function() {
    const ctx1 = setupCanvas('viz-3a');
    const ctx2 = setupCanvas('viz-3b');
    let isAnimating = false;
    let animTime = 0;
    let energyHistory = [];
    let areaHistory = [];
    
    function draw() {
        const system = document.getElementById('ctrl-3-system').value;
        let time = parseFloat(document.getElementById('ctrl-3-time').value) / 50;
        
        if (isAnimating) {
            animTime += 0.02;
            time = animTime % 6;
            document.getElementById('ctrl-3-time').value = time * 50;
        }
        
        document.getElementById('val-3-time').textContent = time.toFixed(2);
        
        const canvas1 = ctx1.canvas;
        const canvas2 = ctx2.canvas;
        const w1 = canvas1.width / (window.devicePixelRatio || 1);
        const h1 = canvas1.height / (window.devicePixelRatio || 1);
        const w2 = canvas2.width / (window.devicePixelRatio || 1);
        const h2 = canvas2.height / (window.devicePixelRatio || 1);
        
        ctx1.clearRect(0, 0, w1, h1);
        ctx2.clearRect(0, 0, w2, h2);
        
        // LEFT PANEL: Show X_H vector field and trajectories
        ctx1.save();
        ctx1.translate(w1/2, h1/2);
        
        // Draw the Hamiltonian vector field X_H = ∂H/∂p ∂/∂x - ∂H/∂x ∂/∂p
        ctx1.globalAlpha = 0.3;
        for (let i = -8; i <= 8; i += 2) {
            for (let j = -8; j <= 8; j += 2) {
                const x = i * 20;
                const p = j * 20;
                
                let dx = 0, dp = 0;
                
                if (system === 'harmonic') {
                    // H = 1/2(p² + x²)
                    // ∂H/∂p = p, ∂H/∂x = x
                    // X_H = p∂_x - x∂_p
                    dx = p;
                    dp = -x;
                } else if (system === 'anharmonic') {
                    // H = 1/2 p² + 1/4 x⁴
                    // ∂H/∂p = p, ∂H/∂x = x³
                    const x_normalized = x / 60; // Consistent scaling with level curves
                    dx = p;
                    dp = -Math.pow(x_normalized, 3) * 60; // Proper scaling back to pixel coordinates
                } else if (system === 'pendulum') {
                    // H = 1/2 p² - cos(x)
                    // ∂H/∂p = p, ∂H/∂x = sin(x)
                    dx = p;
                    dp = -Math.sin(x/40) * 40;
                }
                
                // Normalize and draw
                const mag = Math.sqrt(dx*dx + dp*dp);
                if (mag > 0.1) {
                    const scale = Math.min(15, 300/mag);
                    dx = scale * dx / mag;
                    dp = scale * dp / mag;
                    
                    ctx1.strokeStyle = 'rgba(255,255,255,0.25)';
                    ctx1.lineWidth = 1;
                    ctx1.beginPath();
                    ctx1.moveTo(x, -p);
                    ctx1.lineTo(x + dx, -p - dp);
                    ctx1.stroke();
                    
                    // Arrowhead
                    ctx1.save();
                    ctx1.translate(x + dx, -p - dp);
                    ctx1.rotate(Math.atan2(-dp, dx));
                    ctx1.fillStyle = 'rgba(255,255,255,0.25)';
                    ctx1.beginPath();
                    ctx1.moveTo(0, 0);
                    ctx1.lineTo(-3, 2);
                    ctx1.lineTo(-3, -2);
                    ctx1.fill();
                    ctx1.restore();
                }
            }
        }
        ctx1.globalAlpha = 1;
        
        // Draw level curves H = const
        ctx1.strokeStyle = 'rgba(66, 133, 244, 0.2)';
        ctx1.lineWidth = 1;
        
        if (system === 'harmonic') {
            // Circles: H = 1/2(p² + x²) = E
            for (let E = 0.5; E <= 3; E += 0.5) {
                const r = Math.sqrt(2 * E) * 60;
                ctx1.beginPath();
                ctx1.arc(0, 0, r, 0, 2 * Math.PI);
                ctx1.stroke();
            }
        } else if (system === 'anharmonic') {
            // Curves for H = 1/2 p² + 1/4 x⁴ = E
            for (let E = 0.2; E <= 2; E += 0.4) {
                ctx1.beginPath();
                for (let x = -150; x <= 150; x += 2) {
                    const x_normalized = x / 60;
                    const p_squared = 2 * (E - 0.25 * Math.pow(x_normalized, 4));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        if (x === -150) {
                            ctx1.moveTo(x, -p);
                        } else {
                            ctx1.lineTo(x, -p);
                        }
                    }
                }
                ctx1.stroke();
                
                ctx1.beginPath();
                for (let x = -150; x <= 150; x += 2) {
                    const x_normalized = x / 60;
                    const p_squared = 2 * (E - 0.25 * Math.pow(x_normalized, 4));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        if (x === -150) {
                            ctx1.moveTo(x, p);
                        } else {
                            ctx1.lineTo(x, p);
                        }
                    }
                }
                ctx1.stroke();
            }
        } else if (system === 'pendulum') {
            // Phase portrait for pendulum
            for (let E = -0.8; E <= 2; E += 0.4) {
                ctx1.beginPath();
                for (let x = -3.14; x <= 3.14; x += 0.05) {
                    const p_squared = 2 * (E + Math.cos(x));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        ctx1.lineTo(x * 60, -p);
                    }
                }
                ctx1.stroke();
                
                ctx1.beginPath();
                for (let x = -3.14; x <= 3.14; x += 0.05) {
                    const p_squared = 2 * (E + Math.cos(x));
                    if (p_squared >= 0) {
                        const p = Math.sqrt(p_squared) * 60;
                        ctx1.lineTo(x * 60, p);
                    }
                }
                ctx1.stroke();
            }
        }
        
        // Draw trajectories
        const colors = [
            getColor('accent-blue'),
            getColor('accent-green'),
            getColor('accent-yellow'),
            getColor('accent-red')
        ];
        
        let maxDeltaH = 0;
        
        for (let k = 0; k < 4; k++) {
            ctx1.strokeStyle = colors[k];
            ctx1.lineWidth = 2.5;
            ctx1.globalAlpha = 0.9;
            
            ctx1.beginPath();
            
            // Initial conditions
            let x, p;
            if (system === 'harmonic') {
                const r0 = 60 + k * 20;
                const theta0 = k * Math.PI / 2;
                x = r0 * Math.cos(theta0) / 60;
                p = r0 * Math.sin(theta0) / 60;
            } else if (system === 'anharmonic') {
                x = (k - 1.5) * 0.5;
                p = 1.0 - k * 0.2;
            } else {
                x = (k - 1.5) * 0.8;
                p = 0.5 + k * 0.1;
            }
            
            // Calculate initial energy
            let H0;
            if (system === 'harmonic') {
                H0 = 0.5 * (p*p + x*x);
            } else if (system === 'anharmonic') {
                H0 = 0.5 * p*p + 0.25 * Math.pow(x, 4);
            } else {
                H0 = 0.5 * p*p - Math.cos(x);
            }
            
            // Integrate using Runge-Kutta 4
            const dt = 0.005;
            const steps = Math.floor(time / dt);
            
            for (let step = 0; step <= steps; step++) {
                // Draw trajectory
                if (step % 10 === 0) {
                    if (step === 0) ctx1.moveTo(x * 60, -p * 60);
                    else ctx1.lineTo(x * 60, -p * 60);
                }
                
                // RK4 step
                let k1x, k1p, k2x, k2p, k3x, k3p, k4x, k4p;
                
                if (system === 'harmonic') {
                    k1x = p;
                    k1p = -x;
                    
                    k2x = p + 0.5*dt*k1p;
                    k2p = -(x + 0.5*dt*k1x);
                    
                    k3x = p + 0.5*dt*k2p;
                    k3p = -(x + 0.5*dt*k2x);
                    
                    k4x = p + dt*k3p;
                    k4p = -(x + dt*k3x);
                } else if (system === 'anharmonic') {
                    k1x = p;
                    k1p = -Math.pow(x, 3);
                    
                    k2x = p + 0.5*dt*k1p;
                    k2p = -Math.pow(x + 0.5*dt*k1x, 3);
                    
                    k3x = p + 0.5*dt*k2p;
                    k3p = -Math.pow(x + 0.5*dt*k2x, 3);
                    
                    k4x = p + dt*k3p;
                    k4p = -Math.pow(x + dt*k3x, 3);
                } else {
                    k1x = p;
                    k1p = -Math.sin(x);
                    
                    k2x = p + 0.5*dt*k1p;
                    k2p = -Math.sin(x + 0.5*dt*k1x);
                    
                    k3x = p + 0.5*dt*k2p;
                    k3p = -Math.sin(x + 0.5*dt*k2x);
                    
                    k4x = p + dt*k3p;
                    k4p = -Math.sin(x + dt*k3x);
                }
                
                x += dt * (k1x + 2*k2x + 2*k3x + k4x) / 6;
                p += dt * (k1p + 2*k2p + 2*k3p + k4p) / 6;
                
                // Calculate energy
                let H;
                if (system === 'harmonic') {
                    H = 0.5 * (p*p + x*x);
                } else if (system === 'anharmonic') {
                    H = 0.5 * p*p + 0.25 * Math.pow(x, 4);
                } else {
                    H = 0.5 * p*p - Math.cos(x);
                }
                
                maxDeltaH = Math.max(maxDeltaH, Math.abs(H - H0));
            }
            
            ctx1.stroke();
            ctx1.globalAlpha = 1;
            
            // Mark current position
            ctx1.fillStyle = colors[k];
            ctx1.beginPath();
            ctx1.arc(x * 60, -p * 60, 4, 0, 2 * Math.PI);
            ctx1.fill();
        }
        
        // Calculate divergence numerically: div(X_H) = ∂(∂H/∂p)/∂x + ∂(-∂H/∂x)/∂p
        function calculateDivergence(system, x, p) {
            if (system === 'harmonic') {
                // X_H = p∂_x - x∂_p → div = ∂(p)/∂x + ∂(-x)/∂p = 0 + 0 = 0
                return 0;
            } else if (system === 'anharmonic') {
                // X_H = p∂_x - x³∂_p → div = ∂(p)/∂x + ∂(-x³)/∂p = 0 + 0 = 0  
                return 0;
            } else if (system === 'pendulum') {
                // X_H = p∂_x - sin(x)∂_p → div = ∂(p)/∂x + ∂(-sin(x))/∂p = 0 + 0 = 0
                return 0;
            }
            return 0;
        }

        // Compute max divergence across sample points
        let maxDiv = 0;
        for (let i = -8; i <= 8; i += 4) {
            for (let j = -8; j <= 8; j += 4) {
                const x = i * 20;
                const p = j * 20;
                const div = calculateDivergence(system, x, p);
                maxDiv = Math.max(maxDiv, Math.abs(div));
            }
        }
        
        document.getElementById('delta-h').textContent = maxDeltaH.toFixed(6);
        document.getElementById('div-xh').textContent = maxDiv.toFixed(6);
        
        ctx1.restore();
        
        // RIGHT PANEL: Show conservation properties
        ctx2.save();
        ctx2.translate(w2/2, h2/2);
        
        // Title
        ctx2.fillStyle = getColor('text-primary');
        ctx2.font = 'bold 14px monospace';
        ctx2.textAlign = 'center';
        ctx2.fillText('Verification of Conservation Laws', 0, -160);
        
        // --- Symplectic helpers (separable H = T(p)+V(x)) ---
function dVdx(system, x){
  if (system === 'harmonic')   return x;           // V = ½ x^2
  if (system === 'anharmonic') return x*x*x;       // V = ¼ x^4
  if (system === 'pendulum')   return Math.sin(x); // V = 1 - cos x (const shift irrelevant)
  return 0;
}
function dTdp(p){ return p; } // T = ½ p^2

// One Störmer–Verlet step (area-preserving)
function verletStep(system, x, p, dt){
  const p_half = p - 0.5*dt * dVdx(system, x);
  const x_new  = x + dt * dTdp(p_half);
  const p_new  = p_half - 0.5*dt * dVdx(system, x_new);
  return {x: x_new, p: p_new};
}

// --- Build test region (more points = smoother & stabler area) ---
const testRegion = [];
const N = 60; // was 20
for (let i = 0; i < N; i++) {
  const ang = 2 * Math.PI * i / N;
  testRegion.push({
    x: 0.5 + 0.25 * Math.cos(ang),  // slightly larger ellipse
    p: 0.5 + 0.18 * Math.sin(ang)
  });
}

// Draw initial region
ctx2.fillStyle = 'rgba(66, 133, 244, 0.3)';
ctx2.strokeStyle = getColor('accent-blue');
ctx2.lineWidth = 2;
ctx2.beginPath();
for (let i = 0; i <= N; i++) {
  const pt = testRegion[i % N];
  if (i === 0) ctx2.moveTo(pt.x * 100, -pt.p * 100);
  else ctx2.lineTo(pt.x * 100, -pt.p * 100);
}
ctx2.fill();
ctx2.stroke();

// --- Evolve region with symplectic integrator ---
const evolvedRegion = [];
{
  const dt = 0.01;
  const steps = Math.max(1, Math.floor(time / dt));
  for (const pt of testRegion) {
    let x = pt.x, p = pt.p;
    for (let s = 0; s < steps; s++) {
      const np = verletStep(system, x, p, dt);
      x = np.x; p = np.p;
    }
    evolvedRegion.push({x, p});
  }
}

// Draw evolved region
ctx2.fillStyle = 'rgba(234, 67, 53, 0.3)';
ctx2.strokeStyle = getColor('accent-red');
ctx2.beginPath();
for (let i = 0; i <= N; i++) {
  const pt = evolvedRegion[i % N];
  if (i === 0) ctx2.moveTo(pt.x * 100, -pt.p * 100);
  else ctx2.lineTo(pt.x * 100, -pt.p * 100);
}
ctx2.fill();
ctx2.stroke();

// --- Areas (Shoelace) in (x,p) coordinates ---
function polygonArea(region){
  let a = 0;
  for (let i = 0; i < region.length; i++) {
    const j = (i + 1) % region.length;
    a += region[i].x * region[j].p - region[j].x * region[i].p;
  }
  return Math.abs(a) / 2;
}
const area0 = polygonArea(testRegion);
const area1 = polygonArea(evolvedRegion);
const areaRatio = area1 / area0;

        
        // Display results
        ctx2.fillStyle = getColor('text-primary');
        ctx2.font = '12px monospace';
        ctx2.textAlign = 'left';
        ctx2.fillText('Initial Area:', -160, 120);
        ctx2.fillText(`A₀ = ${area0.toFixed(4)}`, -160, 140);
        
        ctx2.fillText('Final Area:', 20, 120);
        ctx2.fillText(`A(t) = ${area1.toFixed(4)}`, 20, 140);
        
        ctx2.textAlign = 'center';
        ctx2.font = 'bold 14px monospace';
        ctx2.fillStyle = getColor('accent-green');
        ctx2.fillText(`Area Ratio = ${areaRatio.toFixed(6)}`, 0, 170);
        ctx2.fillText('✓ ℒ_Xₕ(ω) = 0', 0, -130);
        
        ctx2.restore();
        
        if (isAnimating) {
            requestAnimationFrame(draw);
        }
    }
    
    document.getElementById('btn-3-animate').addEventListener('click', () => {
        isAnimating = !isAnimating;
        document.getElementById('btn-3-animate').textContent = isAnimating ? 'Stop' : 'Animate Flow';
        document.getElementById('btn-3-animate').classList.toggle('active', isAnimating);
        if (isAnimating) draw();
    });
    
    document.getElementById('btn-3-reset').addEventListener('click', () => {
        animTime = 0;
        energyHistory = [];
        areaHistory = [];
        document.getElementById('ctrl-3-time').value = 0;
        isAnimating = false;
        document.getElementById('btn-3-animate').textContent = 'Animate Flow';
        document.getElementById('btn-3-animate').classList.remove('active');
        draw();
    });
    
    document.getElementById('ctrl-3-system').addEventListener('change', () => {
        energyHistory = [];
        areaHistory = [];
        draw();
    });
    
    document.getElementById('ctrl-3-time').addEventListener('input', () => {
        if (!isAnimating) draw();
    });
    
    draw();
})();
       
// Part 4: Poisson Bracket — exact Jacobi + invariance + homomorphism
(function(){
  // canvases
  const ctxGeo = setupCanvas('pb4-geo');
  const ctxVec = setupCanvas('pb4-vectors');

  // controls
  const selF = document.getElementById('pb4-f');
  const selG = document.getElementById('pb4-g');
  const selH = document.getElementById('pb4-h');
  const sX0  = document.getElementById('pb4-x0');
  const sP0  = document.getElementById('pb4-p0');
  const sSig = document.getElementById('pb4-sigma');
  const btnC = document.getElementById('pb4-conv');

  const valX0  = document.getElementById('pb4-x0-val');
  const valP0  = document.getElementById('pb4-p0-val');
  const valSig = document.getElementById('pb4-sigma-val');

  const outSkew = document.getElementById('pb4-skew');
  const outJac  = document.getElementById('pb4-jacobi');
  const outHomo = document.getElementById('pb4-homo');
  const outInv  = document.getElementById('pb4-inv');

  // analytic library (values + first/second partials)
  const LIB = {
    x:   { f:(x,p)=>x,                fx:(x,p)=>1,           fp:(x,p)=>0,  dxx:()=>0,             dpp:()=>0,            dxp:()=>0 },
    p:   { f:(x,p)=>p,                fx:()=>0,              fp:()=>1,     dxx:()=>0,             dpp:()=>0,            dxp:()=>0 },
    Hx:  { f:(x,p)=>0.5*(x*x+p*p),    fx:(x,p)=>x,           fp:(x,p)=>p,  dxx:()=>1,             dpp:()=>1,            dxp:()=>0 },
    x2:  { f:(x,p)=>0.5*x*x,          fx:(x,p)=>x,           fp:()=>0,     dxx:()=>1,             dpp:()=>0,            dxp:()=>0 },
    p2:  { f:(x,p)=>0.5*p*p,          fx:()=>0,              fp:(x,p)=>p,  dxx:()=>0,             dpp:()=>1,            dxp:()=>0 },
    sinx:{ f:(x,p)=>Math.sin(x),      fx:(x,p)=>Math.cos(x), fp:()=>0,     dxx:(x,p)=>-Math.sin(x),dpp:()=>0,            dxp:()=>0 },
    cosx:{ f:(x,p)=>Math.cos(x),      fx:(x,p)=>-Math.sin(x),fp:()=>0,     dxx:(x,p)=>-Math.cos(x),dpp:()=>0,            dxp:()=>0 },
    xp:  { f:(x,p)=>x*p,              fx:(x,p)=>p,           fp:(x,p)=>x,  dxx:()=>0,             dpp:()=>0,            dxp:()=>1 },
  };

  // sign convention toggle
  let useAssignmentSign = true;
  btnC.onclick = () => {
    useAssignmentSign = !useAssignmentSign;
    btnC.textContent = useAssignmentSign
      ? "Current: {f,g} = ∂f/∂x ∂g/∂p − ∂f/∂p ∂g/∂x"
      : "Current: {f,g} = X_f(g) = ∂f/∂p ∂g/∂x − ∂f/∂x ∂g/∂p";
    draw();
  };

  // helpers for PB + derivatives
  function PB(F,G,x,p){
    const base = F.fx(x,p)*G.fp(x,p) - F.fp(x,p)*G.fx(x,p);
    return useAssignmentSign ? base : -base;
  }
  function PB_x(F,G,x,p){
    const t = F.dxx(x,p)*G.fp(x,p) + F.fx(x,p)*G.dxp(x,p)
            - F.dxp(x,p)*G.fx(x,p) - F.fp(x,p)*G.dxx(x,p);
    return useAssignmentSign ? t : -t;
  }
  function PB_p(F,G,x,p){
    const t = F.dxp(x,p)*G.fp(x,p) + F.fx(x,p)*G.dpp(x,p)
            - F.dpp(x,p)*G.fx(x,p) - F.fp(x,p)*G.dxp(x,p);
    return useAssignmentSign ? t : -t;
  }

  // Lie bracket of Hamiltonian vector fields
  function lieBracket(F,G,x,p){
    const Xf = {x: F.fp(x,p), p: -F.fx(x,p)};
    const Xg = {x: G.fp(x,p), p: -G.fx(x,p)};
    function DX_of(H){
      return { xx:H.dxp(x,p), xp:-H.dxx(x,p), px:H.dpp(x,p), pp:-H.dxp(x,p) };
    }
    const DHf = DX_of(F), DHg = DX_of(G);
    const DHg_Xf = { x: DHg.xx*Xf.x + DHg.xp*Xf.p, p: DHg.px*Xf.x + DHg.pp*Xf.p };
    const DHf_Xg = { x: DHf.xx*Xg.x + DHf.xp*Xg.p, p: DHf.px*Xg.x + DHf.pp*Xg.p };
    return { x: DHg_Xf.x - DHf_Xg.x, p: DHg_Xf.p - DHf_Xg.p };
  }

  // ---------- LEFT CANVAS (geometry) ----------
  function drawLeft(F,G){
    const w = ctxGeo.canvas.width  / (window.devicePixelRatio || 1);
    const h = ctxGeo.canvas.height / (window.devicePixelRatio || 1);
    ctxGeo.clearRect(0,0,w,h);
    ctxGeo.save(); ctxGeo.translate(w/2, h/2);

    // subtle grid
    ctxGeo.strokeStyle = 'rgba(255,255,255,0.08)';
    for(let i=-180;i<=180;i+=30){
      ctxGeo.beginPath(); ctxGeo.moveTo(i,-150); ctxGeo.lineTo(i,150); ctxGeo.stroke();
      ctxGeo.beginPath(); ctxGeo.moveTo(-180,i); ctxGeo.lineTo(180,i); ctxGeo.stroke();
    }

    // vector field X_g
    ctxGeo.strokeStyle = getColor('accent-red');
    for (let i=-5;i<=5;i+=2){
      for (let j=-5;j<=5;j+=2){
        const x=i/2, p=j/2;
        let dx = G.fp(x,p), dp = -G.fx(x,p);
        const m = Math.hypot(dx,dp)||1; dx*=18/m; dp*=18/m;
        const X0 = x*60, P0 = -p*60;
        ctxGeo.beginPath(); ctxGeo.moveTo(X0,P0); ctxGeo.lineTo(X0 + dx, P0 - dp); ctxGeo.stroke();
      }
    }

    // a few f-level hints for simple choices
    ctxGeo.strokeStyle = 'rgba(66,133,244,0.22)';
    if(F===LIB.Hx){
      for(let E=0.5;E<=3;E+=0.5){
        const r = Math.sqrt(2*E)*60;
        ctxGeo.beginPath(); ctxGeo.arc(0,0,r,0,2*Math.PI); ctxGeo.stroke();
      }
    }else if(F===LIB.x2){
      for(let k=20;k<=140;k+=20){
        ctxGeo.beginPath(); ctxGeo.moveTo(-k,-150); ctxGeo.lineTo(-k,150); ctxGeo.stroke();
        ctxGeo.beginPath(); ctxGeo.moveTo(k,-150); ctxGeo.lineTo(k,150);  ctxGeo.stroke();
      }
    }else if(F===LIB.p2){
      for(let k=20;k<=140;k+=20){
        ctxGeo.beginPath(); ctxGeo.moveTo(-180,-k); ctxGeo.lineTo(180,-k); ctxGeo.stroke();
        ctxGeo.beginPath(); ctxGeo.moveTo(-180,k);  ctxGeo.lineTo(180,k);  ctxGeo.stroke();
      }
    }

    // axes labels
    ctxGeo.fillStyle = getColor('text-secondary');
    ctxGeo.font='12px monospace';
    ctxGeo.fillText('x', 170, 12); ctxGeo.fillText('p', 6, -135);

    ctxGeo.restore();
  }

  // ---------- RIGHT CANVAS (vector lab) ----------
  function drawVectors(F,G,x0,p0){
    const w = ctxVec.canvas.width  / (window.devicePixelRatio || 1);
    const h = ctxVec.canvas.height / (window.devicePixelRatio || 1);
    ctxVec.clearRect(0,0,w,h);
    ctxVec.save(); ctxVec.translate(w/2, h/2);

    // background disk
    ctxVec.beginPath();
    ctxVec.arc(0,0,110,0,2*Math.PI);
    ctxVec.fillStyle = 'rgba(255,255,255,0.035)';
    ctxVec.fill();

    // compute vectors at (x0,p0)
    const Xf = { x: F.fp(x0,p0), p: -F.fx(x0,p0) };
    const Xg = { x: G.fp(x0,p0), p: -G.fx(x0,p0) };
    const Xpb = { x: PB_p(F,G,x0,p0), p: -PB_x(F,G,x0,p0) };
    const Lbr = lieBracket(F,G,x0,p0);
    const sign = useAssignmentSign ? -1 : +1; // assignment ⇒ minus
    const Xlie = { x: sign*Lbr.x, p: sign*Lbr.p };

    // arrow drawer
    function drawArrow(vx,vp,len,strokeStyle){
      const m = Math.hypot(vx,vp)||1; const ux=vx/m, up=vp/m;
      ctxVec.strokeStyle = strokeStyle; ctxVec.lineWidth = 3;
      ctxVec.beginPath(); ctxVec.moveTo(0,0); ctxVec.lineTo(len*ux, -len*up); ctxVec.stroke();
      // arrow head
      ctxVec.save();
      ctxVec.translate(len*ux, -len*up);
      ctxVec.rotate(Math.atan2(-up, ux));
      ctxVec.beginPath();
      ctxVec.moveTo(0,0); ctxVec.lineTo(-8, 4); ctxVec.lineTo(-8,-4); ctxVec.closePath(); ctxVec.fillStyle = strokeStyle; ctxVec.fill();
      ctxVec.restore();
    }

    const L = 80; // arrow length
    drawArrow(Xf.x,  Xf.p,  L, getComputedStyle(document.documentElement).getPropertyValue('--accent-blue').trim());
    drawArrow(Xg.x,  Xg.p,  L, getComputedStyle(document.documentElement).getPropertyValue('--accent-green').trim());
    drawArrow(Xpb.x, Xpb.p, L, '#b388ff'); // violet
    drawArrow(Xlie.x,Xlie.p, L, '#fbbc04'); // amber

    // small marker for (x0,p0) magnitude (pulse)
    const t = Date.now()/700;
    const r = 6 + 2*Math.sin(t);
    ctxVec.fillStyle = 'rgba(255,255,255,0.25)';
    ctxVec.beginPath(); ctxVec.arc(0,0,r,0,2*Math.PI); ctxVec.fill();

    ctxVec.restore();
  }

  // ---------- KPIs ----------
  function updateKPIs(F,G,H,x0,p0,sigma){
    // skew
    const fg = PB(F,G,x0,p0);
    const gf = PB(G,F,x0,p0);
    outSkew.textContent = (fg+gf).toExponential(2);

    // Jacobi: {{f,g},h} vs {f,{g,h}} − {g,{f,h}}
    const FGx = PB_x(F,G,x0,p0), FGp = PB_p(F,G,x0,p0);
    const GHx = PB_x(G,H,x0,p0), GHp = PB_p(G,H,x0,p0);
    const HFx = PB_x(H,F,x0,p0), HFp = PB_p(H,F,x0,p0);
    const lhs  = FGx*H.fp(x0,p0) - FGp*H.fx(x0,p0);
    const rhs  = (GHx*F.fp(x0,p0) - GHp*F.fx(x0,p0)) - (HFx*G.fp(x0,p0) - HFp*G.fx(x0,p0));
    outJac.textContent = Math.abs(lhs - rhs).toExponential(2);

    // invariance under x̃=σx, p̃=p/σ
    function gradT(Fn){ return { fx:(1/sigma)*Fn.fx(x0,p0), fp:sigma*Fn.fp(x0,p0) }; }
    const fT = gradT(F), gT = gradT(G);
    const pb_tilde = useAssignmentSign
      ? fT.fx*gT.fp - fT.fp*gT.fx
      : -(fT.fx*gT.fp - fT.fp*gT.fx);
    outInv.textContent = Math.abs(fg - pb_tilde).toExponential(2);

    // homomorphism
    const Xpb = { x: PB_p(F,G,x0,p0), p: -PB_x(F,G,x0,p0) };
    const Lbr = lieBracket(F,G,x0,p0);
    const sign = useAssignmentSign ? -1 : +1;
    const Xlie = { x: sign*Lbr.x, p: sign*Lbr.p };
    outHomo.textContent = Math.hypot(Xpb.x - Xlie.x, Xpb.p - Xlie.p).toExponential(2);
  }

  function draw(){
    const F = LIB[selF.value], G = LIB[selG.value], H = LIB[selH.value];
    const x0 = parseFloat(sX0.value)/100;
    const p0 = parseFloat(sP0.value)/100;
    const sigma = parseFloat(sSig.value)/100;

    valX0.textContent = x0.toFixed(2);
    valP0.textContent = p0.toFixed(2);
    valSig.textContent = sigma.toFixed(2);

    drawLeft(F,G);
    drawVectors(F,G,x0,p0);
    updateKPIs(F,G,H,x0,p0,sigma);
  }

  [selF, selG, selH, sX0, sP0, sSig].forEach(el => el.addEventListener('input', draw));
  draw();
})();

        // Part 5: Euler–Liouville Field
(function () {
  const ctx1 = setupCanvas('viz-5a');
  const ctx2 = setupCanvas('viz-5b');

  const sliderT = document.getElementById('ctrl-5-t');
  const modeSel = document.getElementById('ctrl-5-mode');
  const btnAnim = document.getElementById('btn-5-animate');

  const outT     = document.getElementById('val-5-t');
  const outScale = document.getElementById('scale-5');
  const outVerif = document.getElementById('verification-5');

  let isAnimating = false;

  function draw() {
    // 1) time/scale
    let t = parseFloat(sliderT.value) / 100;
    if (isAnimating) {
      // gentle oscillation in [-2,2]
      t = 2 * Math.sin(Date.now() / 1000);
      sliderT.value = String(Math.round(t * 100));
    }
    const scale = Math.exp(t);
    outT.textContent = t.toFixed(2);
    outScale.textContent = clamp(scale, 1e-6, 1e6).toFixed(3);

    // 2) canvas sizes
    const w1 = ctx1.canvas.width / (window.devicePixelRatio || 1);
    const h1 = ctx1.canvas.height / (window.devicePixelRatio || 1);
    const w2 = ctx2.canvas.width / (window.devicePixelRatio || 1);
    const h2 = ctx2.canvas.height / (window.devicePixelRatio || 1);
    ctx1.clearRect(0, 0, w1, h1);
    ctx2.clearRect(0, 0, w2, h2);

    // 3) LEFT: fiber dilation flow (x fixed, p -> e^t p)
    ctx1.save();
    ctx1.translate(w1 / 2, h1 / 2);

    // fibers
    ctx1.strokeStyle = 'rgba(255,255,255,0.10)';
    ctx1.lineWidth = 1;
    for (let x = -150; x <= 150; x += 50) {
      ctx1.beginPath();
      ctx1.moveTo(x, -180);
      ctx1.lineTo(x, 180);
      ctx1.stroke();
    }

    // base manifold Q (x-axis)
    ctx1.strokeStyle = getColor('accent-green');
    ctx1.lineWidth = 2;
    ctx1.beginPath();
    ctx1.moveTo(-180, 0);
    ctx1.lineTo(180, 0);
    ctx1.stroke();

    // Euler field E = p ∂/∂p  (draw short arrows, length ∝ |p|)
    ctx1.strokeStyle = getColor('accent-yellow');
    ctx1.lineWidth = 1.5;
    for (let i = -3; i <= 3; i++) {
      for (let j = -5; j <= 5; j++) {
        if (j === 0) continue;
        const x = i * 50;
        const p = j * 30;
        const dp = clamp(p * 0.25, -20, 20); // stable arrow length

        ctx1.beginPath();
        ctx1.moveTo(x, -p);
        ctx1.lineTo(x, -p - dp);
        ctx1.stroke();

        if (Math.abs(dp) > 6) {
          ctx1.save();
          ctx1.translate(x, -p - dp);
          ctx1.beginPath();
          ctx1.moveTo(0, 0);
          ctx1.lineTo(-3, dp > 0 ? 5 : -5);
          ctx1.lineTo(3, dp > 0 ? 5 : -5);
          ctx1.closePath();
          ctx1.fillStyle = getColor('accent-yellow');
          ctx1.fill();
          ctx1.restore();
        }
      }
    }

    // flow samples: show p -> e^t p at several x’s
    ctx1.setLineDash([5, 5]);
    ctx1.strokeStyle = getColor('accent-blue');
    ctx1.globalAlpha = 0.65;
    for (let i = -2; i <= 2; i++) {
      const x = i * 60;
      for (let j = -3; j <= 3; j++) {
        if (j === 0) continue;
        const p0 = j * 40;
        const p1 = p0 * scale;
        if (Math.abs(p1) < 180) {
          ctx1.beginPath();
          ctx1.moveTo(x, -p0);
          ctx1.lineTo(x, -p1);
          ctx1.stroke();

          // endpoint marker
          ctx1.beginPath();
          ctx1.arc(x, -p1, 3, 0, 2 * Math.PI);
          ctx1.fillStyle = getColor('accent-red');
          ctx1.fill();
        }
      }
    }
    ctx1.setLineDash([]);
    ctx1.globalAlpha = 1;
    ctx1.restore();

    // 4) RIGHT: verification modes
    ctx2.save();
    ctx2.translate(w2 / 2, h2 / 2);

    const mode = modeSel.value;

    if (mode === 'scaling') {
      // (φ_t^E)*ω = e^t ω  — visualize as height scaling of an area element
      const W = 90, H = 60;

      // original ω area tile
      ctx2.fillStyle = 'rgba(66, 133, 244, 0.30)';
      ctx2.strokeStyle = getColor('accent-blue');
      ctx2.lineWidth = 2;
      ctx2.fillRect(-W / 2, -H / 2, W, H);
      ctx2.strokeRect(-W / 2, -H / 2, W, H);

      // scaled tile
      const Hs = clamp(H * scale, 1e-6, 1e6);
      ctx2.fillStyle = 'rgba(234, 67, 53, 0.30)';
      ctx2.strokeStyle = getColor('accent-red');
      ctx2.fillRect(-W / 2, -Hs / 2, W, Hs);
      ctx2.strokeRect(-W / 2, -Hs / 2, W, Hs);

      // labels
      ctx2.fillStyle = getColor('text-primary');
      ctx2.font = '14px monospace';
      ctx2.textAlign = 'center';
      ctx2.fillText('ω', 0, -H / 2 - 18);
      ctx2.fillText(`e^t · ω`, 0, -Hs / 2 - 18);

      outVerif.innerHTML = `Pullback: <span class="value">(φᵗᴱ)*ω = ${scale.toFixed(3)} · ω</span> ✓`;

    } else if (mode === 'contraction') {
  // i_E(ω) = Θ — synchronized with left-panel scale e^t
  // We read 't' and 'scale' earlier in draw(), so this stays in sync.
  const outVerif = document.getElementById('verification-5');

  ctx2.fillStyle = getColor('text-primary');
  ctx2.font = '14px monospace';
  ctx2.textAlign = 'center';
  ctx2.fillText('Contraction  i_E(ω) = Θ  at a fixed point', 0, -130);

  // Fixed test point in this panel
  const X = -40;
  const Y = 10;

  // Draw a fixed ω "tile" centered at (X, Y)
  const a = 44; // tile side
  ctx2.fillStyle = 'rgba(66,133,244,0.22)';
  ctx2.strokeStyle = getColor('accent-blue');
  ctx2.lineWidth = 2;
  ctx2.fillRect(X - a/2, Y - a/2, a, a);
  ctx2.strokeRect(X - a/2, Y - a/2, a, a);
  
  const E_len = 24 * scale; // ↑ lengthens when e^t grows

  // Yellow arrow: E = p ∂/∂p (vertical direction in (x,p) panel)
  ctx2.strokeStyle = getColor('accent-yellow');
  ctx2.lineWidth = 3;
  ctx2.beginPath();
  ctx2.moveTo(X, Y);
  ctx2.lineTo(X, Y - E_len);
  ctx2.stroke();
  ctx2.save();
  ctx2.translate(X, Y - E_len);
  ctx2.beginPath();
  ctx2.moveTo(0, 0);
  ctx2.lineTo(-4, -6);
  ctx2.lineTo(4, -6);
  ctx2.closePath();
  ctx2.fillStyle = getColor('accent-yellow');
  ctx2.fill();
  ctx2.restore();

  // A small fixed dx arrow (visualising the pairing p·dx)
  const dxLen = 26;
  ctx2.strokeStyle = getColor('accent-green');
  ctx2.lineWidth = 2.5;
  ctx2.beginPath();
  ctx2.moveTo(X + 18, Y + 18);
  ctx2.lineTo(X + 18 + dxLen, Y + 18);
  ctx2.stroke();
  ctx2.save();
  ctx2.translate(X + 18 + dxLen, Y + 18);
  ctx2.beginPath();
  ctx2.moveTo(0, 0);
  ctx2.lineTo(-5, 3);
  ctx2.lineTo(-5, -3);
  ctx2.closePath();
  ctx2.fillStyle = getColor('accent-green');
  ctx2.fill();
  ctx2.restore();

  // Caption + verification text
  ctx2.fillStyle = getColor('text-primary');
  ctx2.font = '12px monospace';
  ctx2.fillText('E vertical;   Θ = p · dx', 0, 108);

  outVerif.innerHTML = `Contraction: <span class="value">i_E(ω) = Θ</span> ✓`;


    } else if (mode === 'liouville') {
  // ℒ_E ω = ω 
  ctx2.fillStyle = getColor('text-primary');
  ctx2.font = '14px monospace';
  ctx2.textAlign = 'center';
  ctx2.fillText('Lie derivative of ω along E', 0, -120);

  const S = 65;
  ctx2.strokeStyle = getColor('accent-blue');
  ctx2.lineWidth = 2;
  ctx2.strokeRect(-S, -18, 2 * S, 36);

  // gentle alpha pulse
  const alpha = 0.6 + 0.35 * Math.sin(Date.now() / 600);
  ctx2.globalAlpha = alpha;
  ctx2.fillStyle = getColor('accent-green');
  ctx2.font = 'bold 20px monospace';
  ctx2.fillText('ℒ_E(ω) = ω', 0, 8);
  ctx2.globalAlpha = 1;

  ctx2.fillStyle = getColor('text-primary');
  ctx2.font = '12px monospace';
  ctx2.fillText('Cartan: ℒ_E = d∘i_E + i_E∘d;  i_E(ω)=Θ,  dΘ=ω', 0, 60);

  outVerif.innerHTML = `Lie derivative: <span class="value">ℒ_E ω = ω</span> ✓`;


    } else if (mode === 'coordinate') {
  // E has the same form in any canonical coordinates:
  // E = Σ p_i ∂/∂p_i  =  Σ p̃_i ∂/∂p̃_i
  // Tie rotation to the same time param t so it animates only when Animate is on.
  const theta = 1.2 * t; // radians

  ctx2.fillStyle = getColor('text-primary');
  ctx2.font = '14px monospace';
  ctx2.textAlign = 'center';
  ctx2.fillText('Coordinate invariance of E', 0, -130);

  // Original axes (blue)
  ctx2.strokeStyle = getColor('accent-blue');
  ctx2.lineWidth = 2;
  ctx2.beginPath(); ctx2.moveTo(-140, 0); ctx2.lineTo(140, 0); ctx2.stroke();
  ctx2.beginPath(); ctx2.moveTo(0, -140); ctx2.lineTo(0, 140); ctx2.stroke();

  // Rotated axes (red)
  ctx2.save();
  ctx2.rotate(theta);
  ctx2.strokeStyle = getColor('accent-red');
  ctx2.lineWidth = 2;
  ctx2.beginPath(); ctx2.moveTo(-140, 0); ctx2.lineTo(140, 0); ctx2.stroke();
  ctx2.beginPath(); ctx2.moveTo(0, -140); ctx2.lineTo(0, 140); ctx2.stroke();
  ctx2.restore();

  // Show a momentum vector in each frame with the same magnitude
  const pLen = 70;

  // In original frame, draw p along +p-axis
  ctx2.strokeStyle = getColor('accent-blue');
  ctx2.lineWidth = 3;
  ctx2.beginPath();
  ctx2.moveTo(0, 0);
  ctx2.lineTo(0, -pLen);
  ctx2.stroke();

  // In rotated frame, draw p̃ along +p̃-axis
  ctx2.save();
  ctx2.rotate(theta);
  ctx2.strokeStyle = getColor('accent-red');
  ctx2.lineWidth = 3;
  ctx2.beginPath();
  ctx2.moveTo(0, 0);
  ctx2.lineTo(0, -pLen);
  ctx2.stroke();
  ctx2.restore();

  // Labels
  ctx2.fillStyle = getColor('text-primary');
  ctx2.font = '12px monospace';
  ctx2.fillText('p-axis', -48, -8);
  ctx2.save();
  ctx2.rotate(theta);
  ctx2.fillText('p̃-axis', -48, -8);
  ctx2.restore();

  // Caption
  ctx2.font = '12px monospace';
  ctx2.fillText('E = Σ p_i ∂/∂p_i  =  Σ p̃_i ∂/∂p̃_i  (same form)', 0, 118);

  // Verification message
  document.getElementById('verification-5').innerHTML =
    `E form: <span class="value">invariant</span> (axes rotating)`;
}


    ctx2.restore();

    if (isAnimating) requestAnimationFrame(draw);
  }

  // helpers
  function clamp(v, lo, hi) { return Math.max(lo, Math.min(hi, v)); }
  function drawAxes(ctx) {
    ctx.beginPath(); ctx.moveTo(-150, 0); ctx.lineTo(150, 0); ctx.stroke();
    ctx.beginPath(); ctx.moveTo(0, -150); ctx.lineTo(0, 150); ctx.stroke();
  }

  // events
  btnAnim.addEventListener('click', () => {
    isAnimating = !isAnimating;
    btnAnim.textContent = isAnimating ? 'Stop' : 'Animate Flow';
    btnAnim.classList.toggle('active', isAnimating);
    if (isAnimating) draw();
  });

  sliderT.addEventListener('input', () => {
    if (!isAnimating) draw();
  });

  modeSel.addEventListener('change', () => {
    draw();
  });

  // initial render
  draw();
})();
    </script>
</body>
</html>
